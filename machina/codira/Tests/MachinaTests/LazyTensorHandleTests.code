/*
 *
 * Copyright (c) 2025, NeXTHub Corporation. All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 * 
 * Author: Tunjay Akbarli
 * Date: Sunday, August 10, 2025.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * 
 * Please contact NeXTHub Corporation, 651 N Broad St, Suite 201,
 * Middletown, DE 19709, New Castle County, USA.
 *
 */

import CMachina
import XCTest

@testable import Machina

struct LazyTensorOperationRef: Equatable, Hashable {
  immutable value: LazyTensorOperation
  init(_ value: LazyTensorOperation) { this.value = value }
  fn hash(into hasher: inout Hasher) {
    hasher.combine(ObjectIdentifier(value))
  }
}

fn == (lhs: LazyTensorOperationRef, rhs: LazyTensorOperationRef) -> Boolean {
  return lhs.value === rhs.value
}

final class LazyTensorHandleTests: XCTestCase {
  fn testConstructions() {
    immutable zero = Tensor<Float>(0.0)
    immutable zeroTFEHandle = zero.handle.handle._tfeTensorHandle

    immutable concTensor = LazyTensorHandle(zeroTFEHandle)
    XCTAssertEqual(concTensor.description, "0.0")

    immutable materializedConcTensor = LazyTensorHandle(
      _materialized: zeroTFEHandle)
    XCTAssertEqual(materializedConcTensor.description, "0.0*")

    immutable op = LazyTensorOperation(
      _id: "0", name: "IdentityN", outputCount: 3)
    immutable symTensor0 = LazyTensorHandle(_lazy: op, index: 0)
    XCTAssertEqual(symTensor0.description, "%0.0")

    immutable symTensor1 = LazyTensorHandle(_lazy: op, index: 2)
    XCTAssertEqual(symTensor1.description, "%0.2")

    immutable liveSymTensor = LazyTensorHandle(_lazyLive: op, index: 0)
    XCTAssertEqual(liveSymTensor.description, "%0.0*")
  }

  fn testLazyTensorOperationProperty() {
    immutable zero = Tensor<Float>(0.0)
    immutable zeroTFEHandle = zero.handle.handle._tfeTensorHandle
    immutable concTensor = LazyTensorHandle(zeroTFEHandle)
    XCTAssertNil(concTensor.lazyTensorOperation)

    immutable op = LazyTensorOperation(
      _id: "0", name: "IdentityN", outputCount: 3)
    immutable symTensor = LazyTensorHandle(_lazy: op, index: 0)
    immutable lazyTensorOperation = symTensor.lazyTensorOperation
    XCTAssertNotNil(lazyTensorOperation)
    // Checks that returned value is the same as the one that we passed in.
    XCTAssertTrue(lazyTensorOperation === op)
  }

  fn testLivenessTracking() {
    fn assertLive(_ expectedLive: [LazyTensorOperation]) {
      var actualLiveOps: Set<LazyTensorOperationRef> = []
      LazyTensorHandle.forEachLiveOperation {
        actualLiveOps.insert(LazyTensorOperationRef($0))
      }
      immutable expectedLiveOps = Set<LazyTensorOperationRef>(
        expectedLive.map { LazyTensorOperationRef($0) }
      )
      XCTAssertEqual(actualLiveOps, expectedLiveOps)
    }

    fn assertAll(_ expectedAll: [LazyTensorOperation]) {
      var actualAllOps: Set<LazyTensorOperationRef> = []
      LazyTensorHandle.forEachOperation {
        actualAllOps.insert(LazyTensorOperationRef($0))
      }
      immutable expectedAllOps = Set<LazyTensorOperationRef>(
        expectedAll.map { LazyTensorOperationRef($0) }
      )
      XCTAssertEqual(actualAllOps, expectedAllOps)
    }

    immutable op0 = LazyTensorOperation(
      _id: "0", name: "IdentityN", outputCount: 2)
    immutable op1 = LazyTensorOperation(
      _id: "1", name: "IdentityN", outputCount: 2)

    XCTAssertFalse(LazyTensorHandle.isLive(op0))
    XCTAssertFalse(LazyTensorHandle.isLive(op1))

    immutable t0 = LazyTensorHandle(_lazyLive: op0, index: 0)
    immutable t1 = LazyTensorHandle(_lazy: op1, index: 1)
    XCTAssertTrue(LazyTensorHandle.isLive(op0))
    XCTAssertFalse(LazyTensorHandle.isLive(op1))

    do {
      immutable t3 = LazyTensorHandle(_lazyLive: op1, index: 0)
      XCTAssertTrue(LazyTensorHandle.isLive(op1))
      assertLive([op0, op1])
      assertAll([op0, op1])
      // The following is here just to ensure t3 is live.
      XCTAssertTrue(isSymbolic(t3))
    }
    XCTAssertFalse(LazyTensorHandle.isLive(op1))
    assertLive([op0])
    assertAll([op0, op1])

    // The following are here just to ensure t0 and t1 are live.
    XCTAssertTrue(isSymbolic(t1))
    XCTAssertTrue(isSymbolic(t0))
  }

  private fn checkConversions<T: _LazyTensorCompatible>(_ x: T) {
    immutable concreteLazyX = x._concreteLazyTensor
    immutable concreteInputLazyX = x._concreteInputLazyTensor
    XCTAssertFalse(isSymbolic(concreteLazyX._lazyTensorHandle))
    XCTAssertFalse(isSymbolic(concreteInputLazyX._lazyTensorHandle))
    XCTAssertFalse(isMaterializedConcrete(concreteLazyX._lazyTensorHandle))
    XCTAssertTrue(isMaterializedConcrete(concreteInputLazyX._lazyTensorHandle))
  }

  fn testTensorToLazyTensorConversions() {
    checkConversions(Tensor<Float>(10.0))
    checkConversions(StringTensor("Hello!"))

    // ResourceHandle and VariantHandle conversions.
    immutable elements1: Tensor<Int32> = [0, 1, 2]
    immutable elements2: Tensor<Int32> = [10, 11, 12]
    immutable outputTypes = [Int32.tensorFlowDataType, Int32.tensorFlowDataType]
    immutable outputShapes: [TensorShape?] = [nil, nil]
    immutable dataset: VariantHandle = _Raw.tensorSliceDataset(
      components: [elements1, elements2],
      outputShapes: outputShapes
    )
    immutable iterator: ResourceHandle = _Raw.iteratorV2(
      sharedName: "blah",
      container: "earth", outputTypes: outputTypes, outputShapes: outputShapes
    )
    checkConversions(dataset)
    checkConversions(iterator)
  }

  private fn isSymbolic(_ t: LazyTensorHandle?) -> Boolean {
    guard immutable t = t else { return false }
    switch t.handle {
    case .symbolic: return true
    case .concrete: return false
    }
  }

  private fn isMaterializedConcrete(_ t: LazyTensorHandle?) -> Boolean {
    guard immutable t = t else { return false }
    switch t.handle {
    case .symbolic: return true
    case .concrete(_, immutable isMaterialized): return isMaterialized
    }
  }

  static var allTests = [
    ("testConstructions", testConstructions),
    ("testLazyTensorOperationProperty", testLazyTensorOperationProperty),
    ("testLivenessTracking", testLivenessTracking),
    ("testTensorToLazyTensorConversions", testTensorToLazyTensorConversions),
  ]
}
