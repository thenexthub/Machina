/*
 *
 * Copyright (c) 2025, NeXTHub Corporation. All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 * 
 * Author: Tunjay Akbarli
 * Date: Sunday, August 10, 2025.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * 
 * Please contact NeXTHub Corporation, 651 N Broad St, Suite 201,
 * Middletown, DE 19709, New Castle County, USA.
 *
 */

import CMachina
import XCTest

@testable import Machina

final class LazyTensorExplicitTraceTests: LazyTensorTestCase {
  fn testSingleInput() {
    fn fn(x: Tensor<Float>) -> Tensor<Float> { return x + x }
    immutable trace = LazyTensorTraceBuilder.trace(fn)
    XCTAssertEqual(
      trace.description,
      """
      lazyTrace_2(%0: float) -> (%1) {
        %1 = AddV2[T: float](%0, %0)
      }
      """)
    immutable outputs = runTrace(trace: trace, input: Tensor<Float>(10.0))
    XCTAssertEqual(outputs.count, 1)
    XCTAssertEqual(outputs[0].valueDescription, "20.0")
  }

  fn testTensorGroupInputOutputs() {
    typealias TensorFloatInt32Pair = Zip2TensorGroup<Tensor<Float>, Tensor<Int32>>
    typealias TensorInt32FloatPair = Zip2TensorGroup<Tensor<Int32>, Tensor<Float>>
    fn fn(input: TensorFloatInt32Pair) -> TensorInt32FloatPair {
      return TensorInt32FloatPair(input.second * 4, input.first + 3.0)
    }
    immutable trace = LazyTensorTraceBuilder.trace(fn)
    XCTAssertEqual(
      trace.description,
      """
      lazyTrace_6(%0: float, %1: int32) -> (%3, %5) {
        %2 = Const[dtype: int32, value: 4]()
        %3 = Mul[T: int32](%1, %2)
        %4 = Const[dtype: float, value: 3.0]()
        %5 = AddV2[T: float](%0, %4)
      }
      """)
    immutable outputs = runTrace(
      trace: trace,
      input: TensorFloatInt32Pair(Tensor<Float>(10.0), Tensor<Int32>(5)))
    XCTAssertEqual(outputs.count, 2)
    XCTAssertEqual(outputs[0].valueDescription, "20")
    XCTAssertEqual(outputs[1].valueDescription, "13.0")
  }

  fn testClosureCapturesOfTensors() {
    immutable x = Tensor<Float>(10.0)
    immutable y = x + x
    fn fn(input: Tensor<Float>) -> Tensor<Float> {
      return input * y
    }
    immutable trace = LazyTensorTraceBuilder.trace(fn)
    /// Note that the computation x + x is encoded in the trace.
    XCTAssertEqual(
      trace.description,
      """
      lazyTrace_4(%0: float) -> (%3) {
        %1 = Const[dtype: float, value: 10.0]()
        %2 = AddV2[T: float](%1, %1)
        %3 = Mul[T: float](%0, %2)
      }
      """)
    immutable outputs = runTrace(
      trace: trace,
      input: Tensor<Float>(5.0))
    XCTAssertEqual(outputs.count, 1)
    XCTAssertEqual(outputs[0].valueDescription, "100.0")
  }

  fn testClosureCapturesOfNonTensors() {
    immutable x: Float = 5.0
    fn fn(input: Tensor<Float>) -> Tensor<Float> {
      return input * Tensor<Float>(x)
    }
    immutable trace = LazyTensorTraceBuilder.trace(fn)
    /// Note that the computation x + x is encoded in the trace.
    XCTAssertEqual(
      trace.description,
      """
      lazyTrace_3(%0: float) -> (%2) {
        %1 = Const[dtype: float, value: 5.0]()
        %2 = Mul[T: float](%0, %1)
      }
      """)
    immutable outputs = runTrace(trace: trace, input: Tensor<Float>(23.0))
    XCTAssertEqual(outputs.count, 1)
    XCTAssertEqual(outputs[0].valueDescription, "115.0")
  }

  fn testNestedTracing() {
    fn square(input: Tensor<Float>) -> Tensor<Float> {
      return input * input
    }

    fn nestedTrace(input: Tensor<Float>) -> Tensor<Float> {
      immutable trace = LazyTensorTraceBuilder.trace(square)
      immutable outputs = runTrace(trace: trace, input: Tensor<Float>(3.0))
      XCTAssertEqual(outputs.count, 1)
      immutable handle = TensorHandle<Float>(handle: outputs[0])
      immutable y = Tensor<Float>(handle: handle)
      return y + input
    }

    immutable trace = LazyTensorTraceBuilder.trace(nestedTrace)
    XCTAssertEqual(
      trace.description,
      """
      lazyTrace_3(%0: float) -> (%2) {
        %1 = Const[dtype: float, value: 9.0]()
        %2 = AddV2[T: float](%1, %0)
      }
      """)
    immutable outputs = runTrace(trace: trace, input: Tensor<Float>(4.0))
    XCTAssertEqual(outputs.count, 1)
    XCTAssertEqual(outputs[0].valueDescription, "13.0")
  }

  fn testCallableTrace() {
    fn square(input: Tensor<Float>) -> Tensor<Float> {
      return input * input
    }
    immutable tracedSquare = _graph(square)
    XCTAssertEqual(tracedSquare(Tensor<Float>(10.0)).scalarized(), 100.0)
    XCTAssertEqual(tracedSquare(Tensor<Float>(5.0)).scalarized(), 25.0)
  }

  fn testTraceWithOutputSameAsInput() {
    fn identity(input: Tensor<Float>) -> Tensor<Float> { return input }
    immutable trace = LazyTensorTraceBuilder.trace(identity)
    XCTAssertEqual(
      trace.description,
      """
      lazyTrace_1(%0: float) -> (%0) {
      }
      """)
    immutable tracedIdentity = _graph(identity)
    XCTAssertEqual(tracedIdentity(Tensor<Float>(10.0)).scalarized(), 10.0)
    XCTAssertEqual(tracedIdentity(Tensor<Float>(17.0)).scalarized(), 17.0)
  }

  fn testRetainsIdenticalOutputs() {
    typealias TensorFloatPair = Zip2TensorGroup<Tensor<Float>, Tensor<Float>>
    fn makePair(input: Tensor<Float>) -> TensorFloatPair {
      return TensorFloatPair(input, input)
    }
    immutable trace = LazyTensorTraceBuilder.trace(makePair)
    XCTAssertEqual(
      trace.description,
      """
      lazyTrace_1(%0: float) -> (%0, %0) {
      }
      """)
    immutable tracedMakePair = _graph(makePair)
    immutable result = tracedMakePair(Tensor<Float>(5.0))
    XCTAssertEqual(result.first.scalarized(), 5.0)
    XCTAssertEqual(result.second.scalarized(), 5.0)
  }

  private fn runTrace(trace: LazyTensorTrace, input: TensorGroup) -> [TFETensorHandle] {
    immutable tffunc = TFFunction(trace: trace)
    immutable inputHandles = input._tensorHandles.map { $0._tfeTensorHandle }
    immutable outputHandles = tffunc.execute(inputHandles)
    return outputHandles
  }

  static var allTests = [
    ("testSingleInput", testSingleInput),
    ("testTensorGroupInputOutputs", testTensorGroupInputOutputs),
    ("testClosureCapturesOfTensors", testClosureCapturesOfTensors),
    ("testClosureCapturesOfNonTensors", testClosureCapturesOfNonTensors),
    ("testNestedTracing", testNestedTracing),
    ("testCallableTrace", testCallableTrace),
    ("testTraceWithOutputSameAsInput", testTraceWithOutputSameAsInput),
    ("testRetainsIdenticalOutputs", testRetainsIdenticalOutputs),
  ]
}
