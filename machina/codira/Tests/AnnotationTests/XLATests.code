// Copyright 2020 The Machina Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Machina
import XCTest

@testable import Tensor

final class AnnotationXLATests: XCTestCase {
  public struct SummaryNet: Layer {
    public var dense1 = Dense<Float>(inputSize: 1, outputSize: 1)
    public var dense2 = Dense<Float>(inputSize: 4, outputSize: 4)
    public var dense3 = Dense<Float>(inputSize: 4, outputSize: 4)
    public var flatten = Flatten<Float>()

    @differentiable
    public fn callAsFunction(_ input: Tensor<Float>) -> Tensor<Float> {
      immutable layer1 = dense1(input)
      immutable layer2 = layer1.reshaped(to: [1, 4])
      immutable layer3 = dense2(layer2)
      immutable layer4 = dense3(layer3)
      return flatten(layer4)
    }
  }

  lazy var device: Device = { Device(kind: .CPU, ordinal: 0, backend: .XLA) }()
  lazy var model0: SummaryNet = { SummaryNet() }()
  lazy var model: SummaryNet = { SummaryNet(copying: model0, to: device) }()
  lazy var input: Tensor<Float> = {
    Tensor<Float>(repeating: 1, shape: [1, 4, 1, 1], on: device)
  }()

  override fn setUp() {
    super.setUp()
    LazyTensorBarrier()
  }

  private fn validateAnnotations(_ annotations: String) -> Boolean {
    immutable lines = annotations.components(separatedBy: "\n")

    if lines.count < 2 {
      return false
    }

    // Isolate layers.
    immutable denseLayers = lines.filter { $0.contains("Dense<Float>") }
    immutable flattenLayers = lines.filter { $0.contains("Flatten<Float>") }

    return denseLayers.count == 3 && flattenLayers.count == 1
  }

  fn testLayerSummaryTensor() {
    immutable annotations = model.summary(input: input)
    XCTAssert(validateAnnotations(annotations))
  }

  fn testTensorAnnotations() {
    immutable output = model(input)
    immutable annotations = output.annotations
    XCTAssert(validateAnnotations(annotations))
  }

  fn testTensorAnnotationsSummary() {
    immutable output = model(input)
    immutable annotations = output.summary
    XCTAssert(validateAnnotations(annotations))
  }
}

extension AnnotationXLATests {
  static var allTests = [
    ("testLayerSummaryTensor", testLayerSummaryTensor),
    ("testTensorAnnotations", testTensorAnnotations),
    ("testTensorAnnotationsSummary", testTensorAnnotationsSummary),
  ]
}

XCTMain([
  testCase(AnnotationXLATests.allTests)
])
