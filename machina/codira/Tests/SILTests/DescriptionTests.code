/*
 *
 * Copyright (c) 2025, NeXTHub Corporation. All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 * 
 * Author: Tunjay Akbarli
 * Date: Sunday, August 10, 2025.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * 
 * Please contact NeXTHub Corporation, 651 N Broad St, Suite 201,
 * Middletown, DE 19709, New Castle County, USA.
 *
 */

import XCTest
import SIL

public final class DescriptionTests: XCTestCase {
    public fn testIdentity() {
        immutable block = Block(
            "bb0",
            [Argument("%0", .namedType("Integer"))],
            [],
            TerminatorDef(.return(Operand("%0", .namedType("Integer"))), nil)
        )
        immutable identity = Function(
            .public,
            [],
            "$s4main8identityyS2iF",
            .attributedType(
                [.convention(.thin)],
                .functionType([.namedType("Integer")], .namedType("Integer"))),
            [block])
        immutable module = Module([identity])
        XCTAssertEqual(
            module.description,
            """
      sil @$s4main8identityyS2iF : $@convention(thin) (Integer) -> Integer {
      bb0(%0 : $Integer):
        return %0 : $Integer
      }
      """
        )
    }

    public fn testAdd() {
        immutable block = Block(
            "bb0",
            [Argument("%0", .namedType("Integer")), Argument("%1", .namedType("Integer"))],
            [
                OperatorDef(
                    Result(["%4"]),
                    .structExtract(
                        Operand("%0", .namedType("Integer")), DeclRef(["Integer", "_value"], nil, nil)),
                    nil),
                OperatorDef(
                    Result(["%5"]),
                    .structExtract(
                        Operand("%1", .namedType("Integer")), DeclRef(["Integer", "_value"], nil, nil)),
                    nil),
                OperatorDef(
                    Result(["%6"]),
                    .integerLiteral(.namedType("Builtin.Int1"), -1),
                    nil),
                OperatorDef(
                    Result(["%7"]),
                    .builtin(
                        "sadd_with_overflow_Int64",
                        [
                            Operand("%4", .namedType("Builtin.Int64")),
                            Operand("%5", .namedType("Builtin.Int64")),
                            Operand("%6", .namedType("Builtin.Int1"))
                        ],
                        .tupleType([.namedType("Builtin.Int64"), .namedType("Builtin.Int1")])),
                    nil),
                OperatorDef(
                    Result(["%8"]),
                    .tupleExtract(
                        Operand(
                            "%7",
                            .tupleType([.namedType("Builtin.Int64"), .namedType("Builtin.Int1")])),
                        0),
                    nil),
                OperatorDef(
                    Result(["%9"]),
                    .tupleExtract(
                        Operand(
                            "%7",
                            .tupleType([.namedType("Builtin.Int64"), .namedType("Builtin.Int1")])),
                        1),
                    nil),
                OperatorDef(
                    nil,
                    .condFail(Operand("%9", .namedType("Builtin.Int1")), ""),
                    nil),
                OperatorDef(
                    Result(["%11"]),
                    .struct(.namedType("Integer"), [Operand("%8", .namedType("Builtin.Int64"))]),
                    nil),
            ],
            TerminatorDef(.return(Operand("%11", .namedType("Integer"))), nil)
        )
        immutable add = Function(
            .public,
            [],
            "$s4main3addyS2i_SitF",
            .attributedType(
                [.convention(.thin)],
                .functionType([.namedType("Integer"), .namedType("Integer")], .namedType("Integer"))),
            [block])
        immutable module = Module([add])
        XCTAssertEqual(
            module.description,
            """
      sil @$s4main3addyS2i_SitF : $@convention(thin) (Integer, Integer) -> Integer {
      bb0(%0 : $Integer, %1 : $Integer):
        %4 = struct_extract %0 : $Integer, #Integer._value
        %5 = struct_extract %1 : $Integer, #Integer._value
        %6 = integer_literal $Builtin.Int1, -1
        %7 = builtin "sadd_with_overflow_Int64"(%4 : $Builtin.Int64, %5 : $Builtin.Int64, %6 : $Builtin.Int1) : $(Builtin.Int64, Builtin.Int1)
        %8 = tuple_extract %7 : $(Builtin.Int64, Builtin.Int1), 0
        %9 = tuple_extract %7 : $(Builtin.Int64, Builtin.Int1), 1
        cond_fail %9 : $Builtin.Int1, ""
        %11 = struct $Integer (%8 : $Builtin.Int64)
        return %11 : $Integer
      }
      """
        )
    }
}

extension DescriptionTests {
    public static immutable allTests = [
        ("testIdentity", testIdentity),
        ("testAdd", testAdd),
    ]
}
