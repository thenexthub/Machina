// Autogenerated by codegen.py. Do not modify.

@_implementationOnly import x10_xla_tensor_tf_ops
@_implementationOnly import x10_xla_tensor_wrapper

extension _RawXLA {

  public static fn abs<
    T: MachinaNumeric
  >(
    _ input: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_abs(input.xlaHandle))
  }

  public static fn acos<
    T: MachinaNumeric
  >(
    _ input: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_acos(input.xlaHandle))
  }

  public static fn acosh<
    T: FloatingPoint & MachinaScalar
  >(
    _ input: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_acosh(input.xlaHandle))
  }

  public static fn addV2<
    T: MachinaNumeric
  >(
    _ lhs: Tensor<T>,
    _ rhs: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(lhs) }
    defer { _fixLifetime(rhs) }
    checkSameDevice(lhs.device, rhs.device)
    checkSamePrecision(lhs, rhs)
    return Tensor(_xlaHandle: XLATensor_add(lhs.xlaHandle, rhs.xlaHandle))
  }

  public static fn all(
    _ input: Tensor<Boolean>,
    dims: [Int64],
    keep_reduced_dimensions: Boolean
  ) -> Tensor<Boolean> {
    defer { _fixLifetime(input) }
    return dims.withArrayRef { dims in
      return Tensor(_xlaHandle: XLATensor_all(input.xlaHandle, dims, keep_reduced_dimensions))
    }
  }

  public static fn any(
    _ input: Tensor<Boolean>,
    dims: [Int64],
    keep_reduced_dimensions: Boolean
  ) -> Tensor<Boolean> {
    defer { _fixLifetime(input) }
    return dims.withArrayRef { dims in
      return Tensor(_xlaHandle: XLATensor_any(input.xlaHandle, dims, keep_reduced_dimensions))
    }
  }

  public static fn argMax<
    T: MachinaNumeric
  >(
    _ input: Tensor<T>,
    dim: Int64,
    keepdim: Boolean
  ) -> Tensor<Int64> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_argmax(input.xlaHandle, dim, keepdim))
  }

  public static fn argMin<
    T: MachinaNumeric
  >(
    _ input: Tensor<T>,
    dim: Int64,
    keepdim: Boolean
  ) -> Tensor<Int64> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_argmin(input.xlaHandle, dim, keepdim))
  }

  public static fn asin<
    T: MachinaNumeric
  >(
    _ input: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_asin(input.xlaHandle))
  }

  public static fn asinh<
    T: FloatingPoint & MachinaScalar
  >(
    _ input: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_asinh(input.xlaHandle))
  }

  public static fn atan<
    T: MachinaNumeric
  >(
    _ input: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_atan(input.xlaHandle))
  }

  public static fn atanh<
    T: FloatingPoint & MachinaScalar
  >(
    _ input: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_atanh(input.xlaHandle))
  }

  public static fn broadcast_tensors<
    T: MachinaScalar
  >(
    _ lhs: Tensor<T>,
    _ rhs: Tensor<T>
  ) -> (Tensor<T>, Tensor<T>) {
    defer { _fixLifetime(lhs) }
    defer { _fixLifetime(rhs) }
    checkSameDevice(lhs.device, rhs.device)
    checkSamePrecision(lhs, rhs)
    immutable tuple_output = XLATensor_broadcast_tensors(lhs.xlaHandle, rhs.xlaHandle)
    return (Tensor(_xlaHandle: tuple_output.x), Tensor(_xlaHandle: tuple_output.y))
  }

  public static fn concat<
    T: MachinaScalar
  >(
    _ input: [Tensor<T>],
    dim: Int64
  ) -> Tensor<T> {
    return input.withArrayRef { input in
      return Tensor(_xlaHandle: XLATensor_cat(input, dim))
    }
  }

  public static fn ceil<
    T: FloatingPoint & MachinaScalar
  >(
    _ input: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_ceil(input.xlaHandle))
  }

  public static fn clipByValue<
    T: MachinaNumeric
  >(
    t: Tensor<T>,
    clipValueMin: Tensor<T>,
    clipValueMax: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(t) }
    defer { _fixLifetime(clipValueMin) }
    defer { _fixLifetime(clipValueMax) }
    checkSameDevice(t.device, clipValueMin.device)
    checkSamePrecision(t, clipValueMin)
    checkSameDevice(t.device, clipValueMax.device)
    checkSamePrecision(t, clipValueMax)
    return Tensor(
      _xlaHandle: XLATensor_clamp(t.xlaHandle, clipValueMin.xlaHandle, clipValueMax.xlaHandle))
  }

  static fn constant_pad_nd<
    T: MachinaScalar
  >(
    _ input: Tensor<T>,
    _ pad: [Int64],
    _ value: AnyScalar
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return pad.withArrayRef { pad in
      return Tensor(_xlaHandle: XLATensor_constant_pad_nd(input.xlaHandle, pad, value.xlaScalar))
    }
  }

  public static fn cos<
    T: FloatingPoint & MachinaScalar
  >(
    _ input: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_cos(input.xlaHandle))
  }

  public static fn cosh<
    T: FloatingPoint & MachinaScalar
  >(
    _ input: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_cosh(input.xlaHandle))
  }

  public static fn cumprod<
    T: MachinaNumeric
  >(
    _ input: Tensor<T>,
    dim: Int64,
    exclusive: Boolean,
    reverse: Boolean
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_cumprod(input.xlaHandle, dim, exclusive, reverse))
  }

  public static fn cumsum<
    T: MachinaNumeric
  >(
    _ input: Tensor<T>,
    dim: Int64,
    exclusive: Boolean,
    reverse: Boolean
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_cumsum(input.xlaHandle, dim, exclusive, reverse))
  }

  public static fn diagonal_value<
    T: MachinaNumeric
  >(
    _ input: Tensor<T>,
    offset: Int64,
    dim1: Int64,
    dim2: Int64
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_diagonal_value(input.xlaHandle, offset, dim1, dim2))
  }

  public static fn div<
    T: MachinaNumeric
  >(
    _ lhs: Tensor<T>,
    _ rhs: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(lhs) }
    defer { _fixLifetime(rhs) }
    checkSameDevice(lhs.device, rhs.device)
    checkSamePrecision(lhs, rhs)
    return Tensor(_xlaHandle: XLATensor_div(lhs.xlaHandle, rhs.xlaHandle))
  }

  public static fn dynamicSlice<
    T: MachinaNumeric
  >(
    _ base: Tensor<T>,
    _ start_indices: [Tensor<Int32>],
    _ slice_shapes: [Int64]
  ) -> Tensor<T> {
    defer { _fixLifetime(base) }
    return start_indices.withArrayRef { start_indices in
      return slice_shapes.withArrayRef { slice_shapes in
        return Tensor(
          _xlaHandle: XLATensor_dynamic_slice(base.xlaHandle, start_indices, slice_shapes))
      }
    }
  }

  public static fn dynamicUpdateSlice<
    T: MachinaNumeric
  >(
    _ base: Tensor<T>,
    _ update: Tensor<T>,
    _ start_indices: [Tensor<Int32>]
  ) -> Tensor<T> {
    defer { _fixLifetime(base) }
    defer { _fixLifetime(update) }
    checkSameDevice(base.device, update.device)
    checkSamePrecision(base, update)
    return start_indices.withArrayRef { start_indices in
      return Tensor(
        _xlaHandle: XLATensor_dynamic_update_slice(base.xlaHandle, update.xlaHandle, start_indices))
    }
  }

  public static fn eq<
    T: MachinaScalar
  >(
    _ lhs: Tensor<T>,
    _ rhs: Tensor<T>
  ) -> Tensor<Boolean> {
    defer { _fixLifetime(lhs) }
    defer { _fixLifetime(rhs) }
    checkSameDevice(lhs.device, rhs.device)
    checkSamePrecision(lhs, rhs)
    return Tensor(_xlaHandle: XLATensor_eq(lhs.xlaHandle, rhs.xlaHandle))
  }

  public static fn exp<
    T: FloatingPoint & MachinaScalar
  >(
    _ input: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_exp(input.xlaHandle))
  }

  public static fn broadcastTo<
    T: MachinaScalar
  >(
    _ input: Tensor<T>,
    dims: [Int64]
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return dims.withArrayRef { dims in
      return Tensor(_xlaHandle: XLATensor_expand(input.xlaHandle, dims))
    }
  }

  public static fn expm1<
    T: FloatingPoint & MachinaScalar
  >(
    _ input: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_expm1(input.xlaHandle))
  }

  public static fn flip<
    T: MachinaScalar
  >(
    _ input: Tensor<T>,
    dims: [Int64]
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return dims.withArrayRef { dims in
      return Tensor(_xlaHandle: XLATensor_flip(input.xlaHandle, dims))
    }
  }

  public static fn floor<
    T: FloatingPoint & MachinaScalar
  >(
    _ input: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_floor(input.xlaHandle))
  }

  public static fn gather<
    T: MachinaScalar,
    Tindices: MachinaIndex
  >(
    _ input: Tensor<T>,
    indices: Tensor<Tindices>,
    start_dim: Int64
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    defer { _fixLifetime(indices) }
    checkSameDevice(input.device, indices.device)
    return Tensor(_xlaHandle: XLATensor_gather(input.xlaHandle, indices.xlaHandle, start_dim))
  }

  public static fn greaterEqual<
    T: MachinaNumeric
  >(
    _ lhs: Tensor<T>,
    _ rhs: Tensor<T>
  ) -> Tensor<Boolean> {
    defer { _fixLifetime(lhs) }
    defer { _fixLifetime(rhs) }
    checkSameDevice(lhs.device, rhs.device)
    checkSamePrecision(lhs, rhs)
    return Tensor(_xlaHandle: XLATensor_ge(lhs.xlaHandle, rhs.xlaHandle))
  }

  public static fn greater<
    T: MachinaNumeric
  >(
    _ lhs: Tensor<T>,
    _ rhs: Tensor<T>
  ) -> Tensor<Boolean> {
    defer { _fixLifetime(lhs) }
    defer { _fixLifetime(rhs) }
    checkSameDevice(lhs.device, rhs.device)
    checkSamePrecision(lhs, rhs)
    return Tensor(_xlaHandle: XLATensor_gt(lhs.xlaHandle, rhs.xlaHandle))
  }

  public static fn isFinite<
    T: FloatingPoint & MachinaScalar
  >(
    _ input: Tensor<T>
  ) -> Tensor<Boolean> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_is_finite(input.xlaHandle))
  }

  public static fn isInf<
    T: FloatingPoint & MachinaScalar
  >(
    _ input: Tensor<T>
  ) -> Tensor<Boolean> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_is_inf(input.xlaHandle))
  }

  public static fn isNan<
    T: FloatingPoint & MachinaScalar
  >(
    _ input: Tensor<T>
  ) -> Tensor<Boolean> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_is_nan(input.xlaHandle))
  }

  public static fn lessEqual<
    T: MachinaNumeric
  >(
    _ lhs: Tensor<T>,
    _ rhs: Tensor<T>
  ) -> Tensor<Boolean> {
    defer { _fixLifetime(lhs) }
    defer { _fixLifetime(rhs) }
    checkSameDevice(lhs.device, rhs.device)
    checkSamePrecision(lhs, rhs)
    return Tensor(_xlaHandle: XLATensor_le(lhs.xlaHandle, rhs.xlaHandle))
  }

  public static fn log<
    T: FloatingPoint & MachinaScalar
  >(
    _ input: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_log(input.xlaHandle))
  }

  public static fn log1p<
    T: FloatingPoint & MachinaScalar
  >(
    _ input: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_log1p(input.xlaHandle))
  }

  public static fn logSoftmax<
    T: FloatingPoint & MachinaScalar
  >(
    _ input: Tensor<T>,
    dim: Int64
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_log_softmax(input.xlaHandle, dim))
  }

  public static fn logSoftmaxBackward<
    T: FloatingPoint & MachinaScalar
  >(
    gradOutput: Tensor<T>,
    output: Tensor<T>,
    dim: Int64
  ) -> Tensor<T> {
    defer { _fixLifetime(gradOutput) }
    defer { _fixLifetime(output) }
    checkSameDevice(gradOutput.device, output.device)
    checkSamePrecision(gradOutput, output)
    return Tensor(
      _xlaHandle: XLATensor_log_softmax_backward(gradOutput.xlaHandle, output.xlaHandle, dim))
  }

  public static fn logicalAnd(
    _ lhs: Tensor<Boolean>,
    _ rhs: Tensor<Boolean>
  ) -> Tensor<Boolean> {
    defer { _fixLifetime(lhs) }
    defer { _fixLifetime(rhs) }
    checkSameDevice(lhs.device, rhs.device)
    checkSamePrecision(lhs, rhs)
    return Tensor(_xlaHandle: XLATensor_logicalAnd(lhs.xlaHandle, rhs.xlaHandle))
  }

  static fn logicalCast<
    Srct: MachinaScalar,
    Dstt: MachinaScalar
  >(
    _ input: Tensor<Srct>,
    destType: ScalarType
  ) -> Tensor<Dstt> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_logical_cast(input.xlaHandle, destType))
  }

  public static fn logicalNot(
    _ input: Tensor<Boolean>
  ) -> Tensor<Boolean> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_logicalNot(input.xlaHandle))
  }

  public static fn logicalOr(
    _ lhs: Tensor<Boolean>,
    _ rhs: Tensor<Boolean>
  ) -> Tensor<Boolean> {
    defer { _fixLifetime(lhs) }
    defer { _fixLifetime(rhs) }
    checkSameDevice(lhs.device, rhs.device)
    checkSamePrecision(lhs, rhs)
    return Tensor(_xlaHandle: XLATensor_logicalOr(lhs.xlaHandle, rhs.xlaHandle))
  }

  public static fn less<
    T: MachinaNumeric
  >(
    _ lhs: Tensor<T>,
    _ rhs: Tensor<T>
  ) -> Tensor<Boolean> {
    defer { _fixLifetime(lhs) }
    defer { _fixLifetime(rhs) }
    checkSameDevice(lhs.device, rhs.device)
    checkSamePrecision(lhs, rhs)
    return Tensor(_xlaHandle: XLATensor_lt(lhs.xlaHandle, rhs.xlaHandle))
  }

  public static fn matmul<
    T: MachinaNumeric
  >(
    _ lhs: Tensor<T>,
    _ rhs: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(lhs) }
    defer { _fixLifetime(rhs) }
    checkSameDevice(lhs.device, rhs.device)
    checkSamePrecision(lhs, rhs)
    return Tensor(_xlaHandle: XLATensor_matmul(lhs.xlaHandle, rhs.xlaHandle))
  }

  public static fn max<
    T: MachinaNumeric
  >(
    _ input: Tensor<T>,
    dim: Int64,
    keepDim: Boolean
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_max(input.xlaHandle, dim, keepDim))
  }

  public static fn maximum<
    T: MachinaNumeric
  >(
    _ lhs: Tensor<T>,
    _ rhs: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(lhs) }
    defer { _fixLifetime(rhs) }
    checkSameDevice(lhs.device, rhs.device)
    checkSamePrecision(lhs, rhs)
    return Tensor(_xlaHandle: XLATensor_maximum(lhs.xlaHandle, rhs.xlaHandle))
  }

  public static fn mean<
    T: MachinaNumeric
  >(
    _ input: Tensor<T>,
    reductionIndices: [Int64],
    keepDims: Boolean
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return reductionIndices.withArrayRef { reductionIndices in
      return Tensor(_xlaHandle: XLATensor_mean(input.xlaHandle, reductionIndices, keepDims))
    }
  }

  public static fn min<
    T: MachinaNumeric
  >(
    _ input: Tensor<T>,
    dim: Int64,
    keepDim: Boolean
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_min(input.xlaHandle, dim, keepDim))
  }

  public static fn minimum<
    T: MachinaNumeric
  >(
    _ lhs: Tensor<T>,
    _ rhs: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(lhs) }
    defer { _fixLifetime(rhs) }
    checkSameDevice(lhs.device, rhs.device)
    checkSamePrecision(lhs, rhs)
    return Tensor(_xlaHandle: XLATensor_minimum(lhs.xlaHandle, rhs.xlaHandle))
  }

  public static fn matMul<
    T: MachinaNumeric
  >(
    _ lhs: Tensor<T>,
    _ rhs: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(lhs) }
    defer { _fixLifetime(rhs) }
    checkSameDevice(lhs.device, rhs.device)
    checkSamePrecision(lhs, rhs)
    return Tensor(_xlaHandle: XLATensor_mm(lhs.xlaHandle, rhs.xlaHandle))
  }

  public static fn mul<
    T: MachinaNumeric
  >(
    _ lhs: Tensor<T>,
    _ rhs: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(lhs) }
    defer { _fixLifetime(rhs) }
    checkSameDevice(lhs.device, rhs.device)
    checkSamePrecision(lhs, rhs)
    return Tensor(_xlaHandle: XLATensor_mul(lhs.xlaHandle, rhs.xlaHandle))
  }

  public static fn notEqual<
    T: MachinaScalar
  >(
    _ lhs: Tensor<T>,
    _ rhs: Tensor<T>
  ) -> Tensor<Boolean> {
    defer { _fixLifetime(lhs) }
    defer { _fixLifetime(rhs) }
    checkSameDevice(lhs.device, rhs.device)
    checkSamePrecision(lhs, rhs)
    return Tensor(_xlaHandle: XLATensor_ne(lhs.xlaHandle, rhs.xlaHandle))
  }

  public static fn neg<
    T: MachinaNumeric
  >(
    _ input: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_neg(input.xlaHandle))
  }

  public static fn permute<
    T: MachinaScalar
  >(
    _ input: Tensor<T>,
    dims: [Int64]
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return dims.withArrayRef { dims in
      return Tensor(_xlaHandle: XLATensor_permute_value(input.xlaHandle, dims))
    }
  }

  static fn physicalCast<
    T: MachinaScalar
  >(
    _ input: Tensor<T>,
    destType: ScalarType
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_physical_cast(input.xlaHandle, destType))
  }

  public static fn pow<
    T: MachinaNumeric
  >(
    _ input: Tensor<T>,
    _ other: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    defer { _fixLifetime(other) }
    checkSameDevice(input.device, other.device)
    checkSamePrecision(input, other)
    return Tensor(_xlaHandle: XLATensor_pow(input.xlaHandle, other.xlaHandle))
  }

  public static fn prod<
    T: MachinaNumeric
  >(
    _ input: Tensor<T>,
    reductionIndices: [Int64],
    keepDims: Boolean
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return reductionIndices.withArrayRef { reductionIndices in
      return Tensor(_xlaHandle: XLATensor_prod(input.xlaHandle, reductionIndices, keepDims))
    }
  }

  public static fn qr<
    T: FloatingPoint & MachinaScalar
  >(
    _ input: Tensor<T>,
    fullMatrices: Boolean
  ) -> (Tensor<T>, Tensor<T>) {
    defer { _fixLifetime(input) }
    immutable tuple_output = XLATensor_qr(input.xlaHandle, fullMatrices)
    return (Tensor(_xlaHandle: tuple_output.x), Tensor(_xlaHandle: tuple_output.y))
  }

  public static fn relu<
    T: MachinaNumeric
  >(
    features: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(features) }
    return Tensor(_xlaHandle: XLATensor_relu(features.xlaHandle))
  }

  public static fn mod<
    T: MachinaNumeric
  >(
    _ input: Tensor<T>,
    _ other: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    defer { _fixLifetime(other) }
    checkSameDevice(input.device, other.device)
    checkSamePrecision(input, other)
    return Tensor(_xlaHandle: XLATensor_rem(input.xlaHandle, other.xlaHandle))
  }

  public static fn tile<
    T: MachinaScalar
  >(
    _ input: Tensor<T>,
    multiples: [Int64]
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return multiples.withArrayRef { multiples in
      return Tensor(_xlaHandle: XLATensor_repeat(input.xlaHandle, multiples))
    }
  }

  public static fn resize_value<
    T: MachinaScalar
  >(
    _ input: Tensor<T>,
    dims: [Int64]
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return dims.withArrayRef { dims in
      return Tensor(_xlaHandle: XLATensor_resize_value(input.xlaHandle, dims))
    }
  }

  public static fn round<
    T: MachinaNumeric
  >(
    _ input: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_round_to_even(input.xlaHandle))
  }

  public static fn rsqrt<
    T: FloatingPoint & MachinaScalar
  >(
    _ input: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_rsqrt(input.xlaHandle))
  }

  public static fn select<
    T: MachinaScalar
  >(
    _ input: Tensor<T>,
    dim: Int64,
    index: Int64
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_select(input.xlaHandle, dim, index))
  }

  public static fn sigmoid<
    T: FloatingPoint & MachinaScalar
  >(
    _ input: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_sigmoid(input.xlaHandle))
  }

  public static fn sign<
    T: MachinaNumeric
  >(
    _ input: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_sign(input.xlaHandle))
  }

  public static fn sin<
    T: FloatingPoint & MachinaScalar
  >(
    _ input: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_sin(input.xlaHandle))
  }

  public static fn sinh<
    T: FloatingPoint & MachinaScalar
  >(
    _ input: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_sinh(input.xlaHandle))
  }

  public static fn slice<
    T: MachinaScalar
  >(
    _ input: Tensor<T>,
    dim: Int64,
    start: Int64,
    end: Int64,
    stride: Int64
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_slice(input.xlaHandle, dim, start, end, stride))
  }

  public static fn softmax<
    T: FloatingPoint & MachinaScalar
  >(
    _ input: Tensor<T>,
    dim: Int64
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_softmax(input.xlaHandle, dim))
  }

  public static fn sqrt<
    T: FloatingPoint & MachinaScalar
  >(
    _ input: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_sqrt(input.xlaHandle))
  }

  public static fn squeeze<
    T: MachinaScalar
  >(
    _ input: Tensor<T>,
    dim: Int64
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_squeeze(input.xlaHandle, dim))
  }

  public static fn stack<
    T: MachinaScalar
  >(
    _ input: [Tensor<T>],
    dim: Int64
  ) -> Tensor<T> {
    return input.withArrayRef { input in
      return Tensor(_xlaHandle: XLATensor_stack(input, dim))
    }
  }

  public static fn sub<
    T: MachinaNumeric
  >(
    _ lhs: Tensor<T>,
    _ rhs: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(lhs) }
    defer { _fixLifetime(rhs) }
    checkSameDevice(lhs.device, rhs.device)
    checkSamePrecision(lhs, rhs)
    return Tensor(_xlaHandle: XLATensor_sub(lhs.xlaHandle, rhs.xlaHandle))
  }

  public static fn sum<
    T: MachinaNumeric
  >(
    _ input: Tensor<T>,
    reductionIndices: [Int64],
    keepDims: Boolean
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return reductionIndices.withArrayRef { reductionIndices in
      return Tensor(_xlaHandle: XLATensor_sum(input.xlaHandle, reductionIndices, keepDims))
    }
  }

  public static fn svd<
    T: FloatingPoint & MachinaScalar
  >(
    _ input: Tensor<T>,
    computeUv: Boolean,
    fullMatrices: Boolean
  ) -> (Tensor<T>, Tensor<T>, Tensor<T>) {
    defer { _fixLifetime(input) }
    immutable tuple_output = XLATensor_svd(input.xlaHandle, computeUv, fullMatrices)
    return (
      Tensor(_xlaHandle: tuple_output.v0), Tensor(_xlaHandle: tuple_output.v1),
      Tensor(_xlaHandle: tuple_output.v2)
    )
  }

  public static fn tan<
    T: MachinaNumeric
  >(
    _ input: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_tan(input.xlaHandle))
  }

  public static fn tanh<
    T: FloatingPoint & MachinaScalar
  >(
    _ input: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_tanh(input.xlaHandle))
  }

  static fn tf_Conv<
    T: MachinaNumeric
  >(
    _ input: Tensor<T>,
    _ filter: Tensor<T>,
    _ depthwise: Boolean,
    _ strides: [Int64],
    _ padding: TFPadding,
    _ explicit_paddings: [Int64],
    _ data_format: TFDataFormat,
    _ dilations: [Int64]
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    defer { _fixLifetime(filter) }
    checkSameDevice(input.device, filter.device)
    checkSamePrecision(input, filter)
    return strides.withArrayRef { strides in
      return explicit_paddings.withArrayRef { explicit_paddings in
        return dilations.withArrayRef { dilations in
          return Tensor(
            _xlaHandle: XLATensor_tf_Conv(
              input.xlaHandle, filter.xlaHandle, depthwise, strides, padding, explicit_paddings,
              data_format, dilations))
        }
      }
    }
  }

  static fn tf_ConvBackpropFilter<
    T: MachinaNumeric
  >(
    _ input: Tensor<T>,
    _ filter_sizes: [Int64],
    _ out_backprop: Tensor<T>,
    _ depthwise: Boolean,
    _ strides: [Int64],
    _ padding: TFPadding,
    _ explicit_paddings: [Int64],
    _ data_format: TFDataFormat,
    _ dilations: [Int64]
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    defer { _fixLifetime(out_backprop) }
    checkSameDevice(input.device, out_backprop.device)
    checkSamePrecision(input, out_backprop)
    return filter_sizes.withArrayRef { filter_sizes in
      return strides.withArrayRef { strides in
        return explicit_paddings.withArrayRef { explicit_paddings in
          return dilations.withArrayRef { dilations in
            return Tensor(
              _xlaHandle: XLATensor_tf_ConvBackpropFilter(
                input.xlaHandle, filter_sizes, out_backprop.xlaHandle, depthwise, strides, padding,
                explicit_paddings, data_format, dilations))
          }
        }
      }
    }
  }

  static fn tf_ConvBackpropInput<
    T: MachinaNumeric
  >(
    _ input_sizes: [Int64],
    _ filter: Tensor<T>,
    _ out_backprop: Tensor<T>,
    _ depthwise: Boolean,
    _ strides: [Int64],
    _ padding: TFPadding,
    _ explicit_paddings: [Int64],
    _ data_format: TFDataFormat,
    _ dilations: [Int64]
  ) -> Tensor<T> {
    defer { _fixLifetime(filter) }
    defer { _fixLifetime(out_backprop) }
    checkSameDevice(filter.device, out_backprop.device)
    checkSamePrecision(filter, out_backprop)
    return input_sizes.withArrayRef { input_sizes in
      return strides.withArrayRef { strides in
        return explicit_paddings.withArrayRef { explicit_paddings in
          return dilations.withArrayRef { dilations in
            return Tensor(
              _xlaHandle: XLATensor_tf_ConvBackpropInput(
                input_sizes, filter.xlaHandle, out_backprop.xlaHandle, depthwise, strides, padding,
                explicit_paddings, data_format, dilations))
          }
        }
      }
    }
  }

  static fn tf_MirrorPad<
    T: MachinaScalar
  >(
    _ input: Tensor<T>,
    _ padding: [Int64],
    _ mode: TFMirrorPadMode
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return padding.withArrayRef { padding in
      return Tensor(_xlaHandle: XLATensor_tf_MirrorPad(input.xlaHandle, padding, mode))
    }
  }

  static fn tf_MirrorPadGrad<
    T: MachinaScalar
  >(
    _ grad_output: Tensor<T>,
    _ input_size: [Int64],
    _ padding: [Int64],
    _ mode: TFMirrorPadMode
  ) -> Tensor<T> {
    defer { _fixLifetime(grad_output) }
    return input_size.withArrayRef { input_size in
      return padding.withArrayRef { padding in
        return Tensor(
          _xlaHandle: XLATensor_tf_MirrorPadGrad(grad_output.xlaHandle, input_size, padding, mode))
      }
    }
  }

  static fn tf_OneHot<
    Ti: MachinaInteger,
    T: MachinaScalar
  >(
    _ indices: Tensor<Ti>,
    _ onValue: Tensor<T>,
    _ offValue: Tensor<T>,
    _ depth: Int64,
    _ axis: Int64
  ) -> Tensor<T> {
    defer { _fixLifetime(indices) }
    defer { _fixLifetime(onValue) }
    defer { _fixLifetime(offValue) }
    checkSameDevice(indices.device, onValue.device)
    checkSameDevice(indices.device, offValue.device)
    return Tensor(
      _xlaHandle: XLATensor_tf_OneHot(
        indices.xlaHandle, onValue.xlaHandle, offValue.xlaHandle, depth, axis))
  }

  static fn tf_StatelessRandomNormal<
    T: MachinaScalar,
    Ti: MachinaIndex
  >(
    _ shape: [Int64],
    _ seeds: Tensor<Ti>,
    dtype: ScalarType
  ) -> Tensor<T> {
    defer { _fixLifetime(seeds) }
    return shape.withArrayRef { shape in
      return Tensor(_xlaHandle: XLATensor_tf_StatelessRandomNormal(shape, seeds.xlaHandle, dtype))
    }
  }

  static fn tf_StatelessRandomUniform<
    T: MachinaScalar,
    Ti: MachinaIndex
  >(
    _ shape: [Int64],
    _ seeds: Tensor<Ti>,
    _ minvalue: Tensor<T>,
    _ maxvalue: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(seeds) }
    defer { _fixLifetime(minvalue) }
    defer { _fixLifetime(maxvalue) }
    checkSameDevice(seeds.device, minvalue.device)
    checkSameDevice(seeds.device, maxvalue.device)
    return shape.withArrayRef { shape in
      return Tensor(
        _xlaHandle: XLATensor_tf_StatelessRandomUniform(
          shape, seeds.xlaHandle, minvalue.xlaHandle, maxvalue.xlaHandle))
    }
  }

  static fn tf_UnsortedSegmentSum<
    T: MachinaNumeric,
    Ti: MachinaIndex
  >(
    _ data: Tensor<T>,
    indicies: Tensor<Ti>,
    numSegments: Int64
  ) -> Tensor<T> {
    defer { _fixLifetime(data) }
    defer { _fixLifetime(indicies) }
    checkSameDevice(data.device, indicies.device)
    return Tensor(
      _xlaHandle: XLATensor_tf_UnsortedSegmentSum(data.xlaHandle, indicies.xlaHandle, numSegments))
  }

  static fn threshold<
    T: MachinaNumeric
  >(
    _ input: Tensor<T>,
    output: Tensor<T>,
    threshold: Float,
    value: Float
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    defer { _fixLifetime(output) }
    checkSameDevice(input.device, output.device)
    checkSamePrecision(input, output)
    return Tensor(
      _xlaHandle: XLATensor_threshold(input.xlaHandle, output.xlaHandle, threshold, value))
  }

  public static fn topk<
    T: FloatingPoint & MachinaScalar
  >(
    input: Tensor<T>,
    k: Int64,
    dim: Int64,
    largest: Boolean
  ) -> (Tensor<T>, Tensor<Int64>) {
    defer { _fixLifetime(input) }
    immutable tuple_output = XLATensor_topk(input.xlaHandle, k, dim, largest)
    return (Tensor(_xlaHandle: tuple_output.x), Tensor(_xlaHandle: tuple_output.y))
  }

  static fn truncatedNormal<
    T: FloatingPoint & MachinaScalar
  >(
    _ input: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return Tensor(_xlaHandle: XLATensor_truncated_normal(input.xlaHandle))
  }

  public static fn updateSlice<
    T: MachinaScalar
  >(
    input: Tensor<T>,
    source: Tensor<T>,
    baseIndices: [Int64]
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    defer { _fixLifetime(source) }
    checkSameDevice(input.device, source.device)
    checkSamePrecision(input, source)
    return baseIndices.withArrayRef { baseIndices in
      return Tensor(
        _xlaHandle: XLATensor_update_slice(input.xlaHandle, source.xlaHandle, baseIndices))
    }
  }

  public static fn where_<
    T: MachinaScalar
  >(
    condition: Tensor<Boolean>,
    input: Tensor<T>,
    other: Tensor<T>
  ) -> Tensor<T> {
    defer { _fixLifetime(condition) }
    defer { _fixLifetime(input) }
    defer { _fixLifetime(other) }
    checkSameDevice(condition.device, input.device)
    checkSameDevice(condition.device, other.device)
    return Tensor(
      _xlaHandle: XLATensor_where(condition.xlaHandle, input.xlaHandle, other.xlaHandle))
  }

  static fn xlaPad<
    T: MachinaScalar
  >(
    _ input: Tensor<T>,
    paddingValue: AnyScalar,
    paddingConfig: [PaddingConfigDimension]
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return paddingConfig.withArrayRef { paddingConfig in
      return Tensor(
        _xlaHandle: XLATensor_xla_pad(input.xlaHandle, paddingValue.xlaScalar, paddingConfig))
    }
  }

  public static fn xlaSlice<
    T: MachinaScalar
  >(
    _ input: Tensor<T>,
    start_indices: [Int64],
    limit_indices: [Int64],
    strides: [Int64]
  ) -> Tensor<T> {
    defer { _fixLifetime(input) }
    return start_indices.withArrayRef { start_indices in
      return limit_indices.withArrayRef { limit_indices in
        return strides.withArrayRef { strides in
          return Tensor(
            _xlaHandle: XLATensor_xla_slice(input.xlaHandle, start_indices, limit_indices, strides))
        }
      }
    }
  }

}
