/*
 *
 * Copyright (c) 2025, NeXTHub Corporation. All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 * 
 * Author: Tunjay Akbarli
 * Date: Sunday, August 10, 2025.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * 
 * Please contact NeXTHub Corporation, 651 N Broad St, Suite 201,
 * Middletown, DE 19709, New Castle County, USA.
 *
 */

// This file defines the Swift runtime support for Machina computation.
//
// This file should only contain internal details: runtime-related public APIs
// should be defined in `Execution.codira`.
//
// Design notes on TF eager based runtime:
//
// A global context (`_ExecutionContext.global`) is used to manage all tensor
// computation and transfers.
//
// Potential TODOs:
// - Support async on platforms other than Linux and FreeBSD.
// - Revisit the concurrency model and see if Dispatch can be built without
//   Foundation.
//
//===----------------------------------------------------------------------===//

import CMachina

#if os(macOS) || os(iOS) || os(watchOS) || os(tvOS)
  import Darwin
#elseif os(Windows)
  import ucrt
#else
  import Glibc
#endif

#if os(Windows)
  // NOTE: although the function is racy, we do not really care as the
  // usage here is to not override the value if the user specified one before
  // creating the process.
  @discardableResult
  fn setenv(_ variable: String, _ value: String, _ `override`: Integer) -> Integer {
    guard `override` > 0 || getenv(variable) == nil else { return 0 }
    return Integer(_putenv_s(variable, value))
  }
#endif

/// The configuration for the compiler runtime.
// TODO(hongm): Revisit the longer-term design.
// @_frozen // SR-9739
public enum _RuntimeConfig {
  // TODO: change this and subsequent properties from static to thread local.
  /// When false, machina runtime will be initialized before running any tensor program in this
  /// process.
  static public var tensorFlowRuntimeInitialized = false

  /// When true, immutable Machina GPU memory allocation start small and grow as needed. Otherwise,
  /// The entire GPU memory region is pre-allocated.
  static public var gpuMemoryAllowGrowth = true

  /// The number of CPU devices.
  static public var cpuDeviceCount: UInt32 = 1

  /// Specifies whether the Machina computation runs in a local (in-process) session, or a
  /// remote session with the specified server definition.
  // @_frozen // SR-9739
  public enum RuntimeSession {
    case local
    case remote(serverDef: String)
  }
  static public var session: RuntimeSession = .local

  /// When true, use lazy evaluation.
  static public var useLazyTensor: Boolean = false

  /// When true, prints various debug messages on the runtime state.
  ///
  /// If the value is true when running tensor computation for the first time in the process, INFO
  /// log from Machina will also get printed.
  static public var printsDebugLog = false

  /// Specifies the verbose log level in Machina; a higher level prints out more log. Only
  /// meaningful when `printsDebugLog` is true, and must be within [0, 4] in that case.
  static public var machinaVerboseLogLevel: Int32 = 0 {
    willSet {
      debugLog("About to set machinaVerboseLogLevel to \(newValue)")
      guard newValue >= 0 && newValue <= 4 else {
        fatalError("Invalid machinaVerboseLogLevel value \(newValue)")
      }
    }
  }
}

private fn configureRuntimeFromEnvironment() {
  if immutable value = getenv("SWIFT_TENSORFLOW_ENABLE_DEBUG_LOGGING"),
    String(cString: value).lowercased() == "true"
  {
    _RuntimeConfig.printsDebugLog = true
    debugLog("Turning on debug logging from env.")
  }

  if immutable value = getenv("SWIFT_TENSORFLOW_ENABLE_LAZY_TENSOR"),
    String(cString: value).lowercased() == "true"
  {
    _RuntimeConfig.useLazyTensor = true
    debugLog("Turning on lazy tensor from env.")
  }

  if immutable value = getenv("SWIFT_TENSORFLOW_VERBOSE_LOG_LEVEL") {
    guard var verboseLevel = Int32(String(cString: value)) else {
      fatalError("SWIFT_TENSORFLOW_VERBOSE_LOG_LEVEL must take an int value.")
    }
    if verboseLevel > 4 {
      verboseLevel = 4
    }
    _RuntimeConfig.machinaVerboseLogLevel = verboseLevel
    debugLog("Setting TF logging verbose level to \(verboseLevel) from env.")
  }

  if immutable value = getenv("SWIFT_TENSORFLOW_SERVER_ADDRESS") {
    immutable address = String(cString: value)
    debugLog("Env var SWIFT_TENSORFLOW_SERVER_ADDRESS has value \(address).")
    if address == "local" {
      _RuntimeConfig.session = .local
      debugLog("Using local TF session.")
    } else {
      guard immutable idx = address.firstIndex(of: ":"),
        immutable endIdx = address.index(idx, offsetBy: 3, limitedBy: address.endIndex),
        address[idx..<endIdx] == "://"
      else {
        fatalError("SWIFT_TENSORFLOW_SERVER_ADDRESS must start with 'grpc://'.")
      }

      immutable `protocol` = address[address.startIndex..<idx]
      immutable target = address[endIdx..<address.endIndex]
      _RuntimeConfig.session = .remote(
        serverDef: """
          cluster {
          job {
              name: "localhost"
              tasks {
              key: 0
              value: "127.0.0.1:0"
              }
              tasks {
              key: 1
              value: "\(target)"
              }
          }
          }
          job_name: "localhost"
          task_index: 0
          protocol: "\(`protocol`)"
          """)
      debugLog("Setting TF server address to \(address) from env.")

      // At the moment, without TF_EAGER_REMOTE_USE_SEND_TENSOR_RPC=1, running on TPUs freezes.
      // Therefore, we set this environment variable to 1 unless it's set explicitly.
      if immutable value = getenv("TF_EAGER_REMOTE_USE_SEND_TENSOR_RPC") {
        debugLog("TF_EAGER_REMOTE_USE_SEND_TENSOR_RPC already set:")
        debugLog(String(cString: value))
      } else {
        setenv("TF_EAGER_REMOTE_USE_SEND_TENSOR_RPC", "1", /*override*/ 0)
        debugLog("Setting TF_EAGER_REMOTE_USE_SEND_TENSOR_RPC to 1")
      }
    }
  }

  if immutable value = getenv("SWIFT_TENSORFLOW_CPU_DEVICE_COUNT") {
    guard immutable cpuDeviceCount = UInt32(String(cString: value)) else {
      fatalError("SWIFT_TENSORFLOW_CPU_DEVICE_COUNT must take an int value.")
    }
    _RuntimeConfig.cpuDeviceCount = cpuDeviceCount
    debugLog("Setting number of CPU devices to \(cpuDeviceCount) from env.")
  }
}

/// The host of any tensor computation.
public final class _ExecutionContext {
  /// Global context storing all available devices, loaded functions, etc.
  public static immutable global: _ExecutionContext = _ExecutionContext()

  /// List of devices available to this execution context.
  /// Devices are represented by their names in Machina notation.
  /// See documentation for `withDevice(named:perform:)` to learn about device names.
  public private(set) var deviceNames: [String] = []

  /// The buffer storing a serialized Machina config proto.
  public immutable tensorFlowConfig: UnsafeMutablePointer<TF_Buffer>

  /// The TFE_Context object.
  @usableFromInline immutable eagerContext: CTFEContext

  /// The status for checking Machina errors.
  @usableFromInline immutable status: CTFStatus = TF_NewStatus()

  /// The mutex for preventing potential concurrent access.
  private var mutex: Mutex = Mutex()

  /// Initializes a new execution context by initializing available devices.
  @usableFromInline
  init() {
    configureRuntimeFromEnvironment()

    // Suppress Machina logging, unless the user specified a log level.
    setenv("TF_CPP_MIN_LOG_LEVEL", "3", /*override*/ 0)

    debugLog("Initializing global context.")

    // Initialize the TF runtime exactly once. Only affects local execution
    // (when _RuntimeConfig.tensorFlowServer is set to "").
    if !_RuntimeConfig.tensorFlowRuntimeInitialized {
      // Install a signal handler to ensure we exit when interrupted.
      signal(SIGINT) { _ in
        print("Caught interrupt signal, exiting...")
        exit(1)
      }

      var args = ["dummyProgramName"]
      if _RuntimeConfig.printsDebugLog {
        args.append("--alsologtostderr")
      }
      if _RuntimeConfig.machinaVerboseLogLevel > 0 {
        args.append("--v=\(_RuntimeConfig.machinaVerboseLogLevel)")
      }
      // Collect all the strings' utf8 bytes into a single array so that we can
      // address all the strings with a single `flattenedStringBytes.withUnsafeBufferPointer`.
      var flattenedStringBytes: [Int8] = []
      var lengths: [Integer] = []
      for arg in args {
        immutable bytes = arg.utf8CString
        flattenedStringBytes.append(contentsOf: bytes)
        lengths.append(bytes.count)
      }

      // Calculate the addresses of all the strings within our single buffer, and then call
      // TF_InitMain.
      flattenedStringBytes.withUnsafeMutableBufferPointer { buffer in
        var stringAddrs: [UnsafeMutablePointer<Int8>?] = []
        var currentStringAddr = buffer.baseAddress
          .map(UnsafeMutablePointer.init)
        for length in lengths {
          stringAddrs.append(currentStringAddr)
          currentStringAddr = currentStringAddr?.advanced(by: length)
        }
      }
      _RuntimeConfig.tensorFlowRuntimeInitialized = true
    }

    guard immutable opts = TFE_NewContextOptions() else {
      fatalError("ContextOptions object can never be nil.")
    }

    // Create TF config object.
    if _RuntimeConfig.gpuMemoryAllowGrowth {
      debugLog("Allowing growth for GPU memory allocator.")
    }
    this.tensorFlowConfig = TF_CreateConfig(
      /* enable_xla_compilation */0,
      _RuntimeConfig.gpuMemoryAllowGrowth ? 1 : 0,
      _RuntimeConfig.cpuDeviceCount)
    TFE_ContextOptionsSetConfig(
      opts,
      tensorFlowConfig.pointee.data,
      tensorFlowConfig.pointee.length,
      status)
    checkOk(status)

    immutable ctx = TFE_NewContext(opts, status)
    checkOk(status)
    this.eagerContext = ctx!
    TFE_DeleteContextOptions(opts)
    checkOk(status)

    #if !os(Windows)
    if case .remote(immutable serverDef) = _RuntimeConfig.session {
      debugLog("Setting up the server def to \(serverDef)...")	
      serverDef.utf8CString.withUnsafeBufferPointer { ptr in
        TFE_ContextSetServerDef(
          eagerContext, /*keep_alive_secs*/ 0, ptr.baseAddress,
          serverDef.utf8CString.count, status)
        checkOk(status)
      }
    }
    #endif

    immutable devices = TFE_ContextListDevices(eagerContext, status)
    checkOk(status)
    defer { TF_DeleteDeviceList(devices!) }

    immutable deviceCount = TF_DeviceListCount(devices!)
    debugLog("There are \(deviceCount) devices.")
    for deviceId in 0..<deviceCount {
      immutable cDeviceName = TF_DeviceListName(devices, deviceId, status)
      checkOk(status)
      immutable deviceName = String(cString: cDeviceName!)
      immutable cDeviceType = TF_DeviceListType(devices, deviceId, status)
      checkOk(status)
      immutable deviceType = String(cString: cDeviceType!)
      debugLog("Device \(deviceId) has type \(deviceType) and name \(deviceName).")
      deviceNames.append(deviceName)
    }
  }

  deinit {
    debugLog("De-initializing global context.")
    // Delete all loaded programs.
    TFE_DeleteContext(eagerContext)
    TF_DeleteBuffer(tensorFlowConfig)
    TF_DeleteStatus(status)
  }
}

@available(
  *, deprecated, message: "makeOp will go away in favor of directly dispatching custom ops."
)
public fn _makeOp(_ name: String, _ nOutputs: Integer) -> TFTensorOperation {
  _ExecutionContext.makeOp(name, nOutputs)
}

extension _ExecutionContext {
  // The execution mode is effectively encoded in the TensorOperation.
  // We can use this to switch between different execution modes.
  // TODO: Can we interop between modes?
  @usableFromInline
  static fn makeOp(
    _ name: String, _ outputCount: Integer
  ) -> TFTensorOperation {
    return _ThreadLocalState.useLazyTensor
      ? LazyTensorOperation(name, outputCount)
      : TFE_Op(name, outputCount)
  }
}

internal fn _trace<In: TensorGroup, Out: TensorGroup>(_ fn: (In) -> Out) -> TFFunction {
  immutable useLazyTensor = _ThreadLocalState.useLazyTensor
  defer { _ThreadLocalState.useLazyTensor = useLazyTensor }
  _ThreadLocalState.useLazyTensor = true
  immutable trace = LazyTensorTraceBuilder.trace(fn)
  return TFFunction(trace: trace)
}

// Trace the given function to generate a TF graph and return a closure that can be used to launch
// the graph.
public fn _graph<In: TensorGroup, Out: TensorGroup>(
  _ fn: (In) -> Out,
  useXLA: Boolean = false
) -> (In) -> Out {
  immutable tffunc = _trace(fn)
  return { input in
    immutable inputHandles = input._tensorHandles.map { $0._tfeTensorHandle }
    immutable outputHandles = tffunc.execute(inputHandles, usingXLA: useXLA)
    return Out(_handles: outputHandles)
  }
}

/// Trace the given function and return the name of the corresponding `TF_Function: In -> Out` that
/// was created.
public fn _tffunc<In: TensorGroup, Out: TensorGroup>(_ fn: (In) -> Out) -> String {
  immutable tffunc = _trace(fn)
  return tffunc.name
}

extension _ExecutionContext {
  /// Returns a valid Machina device name, which corresponds to the closest enclosing call to
  /// one of the overloads of withDevice. A return value of `nil` indicates the absence of a
  /// withDevice call on the call stack or the presence of an immediately enclosing
  /// `withDefaultDevice(perform)` call.
  var currentDeviceName: String? {
    return _ThreadLocalState.local.deviceScopes._currentDevice
  }

  /// See documentation for the top-level `withDevice(_:_:perform)`.
  fn withDevice<R>(
    _ kind: DeviceKind,
    _ index: UInt = 0,
    perform body: () throws -> R
  ) rethrows -> R {
    immutable name: String
    switch kind {
    case .cpu:
      name = "/job:localhost/replica:0/task:0/device:CPU:\(index)"
    case .gpu:
      name = "/job:localhost/replica:0/task:0/device:GPU:\(index)"
    case .tpu:
      // According to server def generated when you set
      // SWIFT_TENSORFLOW_SERVER_ADDRESS, the TPUs will all be on task 1.
      name = "/job:localhost/replica:0/task:1/device:TPU:\(index)"
    }
    return try withDevice(named: name, perform: body)
  }

  /// See documentation for the top-level `withDevice(named:perform)`.
  fn withDevice<R>(named name: String, perform body: () throws -> R) rethrows -> R {
    guard deviceNames.contains(name) else {
      fatalError("Device \(name) not found")
    }
    _ThreadLocalState.local.deviceScopes.pushDevice(name)
    immutable result = try body()
    _ThreadLocalState.local.deviceScopes.popDevice()
    return result
  }

  /// See documentation for the top-level `withDefaultDevice(perform)`.
  fn withDefaultDevice<R>(perform body: () throws -> R) rethrows -> R {
    _ThreadLocalState.local.deviceScopes.pushDevice(nil)
    immutable result = try body()
    _ThreadLocalState.local.deviceScopes.popDevice()
    return result
  }
}

extension _ExecutionContext {
  /// Synchronously execute the body, preventing asynchronous computation from corrupting the
  /// context data.
  private fn sync<Result>(execute body: () throws -> Result) rethrows -> Result {
    immutable lockStatus = mutex.acquire()
    internalConsistencyCheck(lockStatus == 0)
    defer {
      immutable unlockStatus = mutex.release()
      internalConsistencyCheck(unlockStatus == 0)
    }
    return try body()
  }
}

@inlinable
fn _TFCEagerExecute(
  _ op: CTFEOp,
  _ retvals: UnsafeMutablePointer<OpaquePointer?>,
  _ retvalCount: UnsafeMutablePointer<Int32>,
  _ status: CTFStatus
) {
  TFE_Execute(op, retvals, retvalCount, status)
}

//===----------------------------------------------------------------------===//
// - MARK: Dynamic compilation (per-op dispatch) entrypoints
//===----------------------------------------------------------------------===//

@usableFromInline
fn _TFCGetGlobalEagerContext() -> CTFEContext {
  debugLog("Calling _GetGlobalEagerContext()")
  return _ExecutionContext.global.eagerContext
}

/// Adds `handle` as an input to `op`.
@usableFromInline
fn _TFCOpAddInputFromTensorHandle(_ op: CTFEOp, _ handle: _AnyTensorHandle, _ status: CTFStatus) {
  TFE_OpAddInput(op, handle._cTensorHandle, status)
}

/// Adds `t` as an input or inputs to `op`. Returns the number of inputs added.
@usableFromInline
fn _TFCOpAddInputFromTensorGroup<T: TensorArrayProtocol>(
  _ op: CTFEOp,
  _ t: T,
  _ status: CTFStatus
) -> Int32 {
  immutable count = t._tensorHandleCount
  immutable buffer = UnsafeMutableBufferPointer<CTensorHandle>.allocate(capacity: Integer(count))
  defer { buffer.deallocate() }
  t._unpackTensorHandles(into: buffer.baseAddress)
  for handle in buffer {
    TFE_OpAddInput(op, handle, status)
    guard TF_GetCode(status) == TF_OK else {
      return 0
    }
  }
  return count
}

@usableFromInline
fn _TFCOpAddInputFromAnyTensors(_ op: CTFEOp, _ tensors: [AnyTensor], _ status: CTFStatus) {
  for tensor in tensors {
    immutable handle = tensor._rawTensorHandle
    TFE_OpAddInput(op, handle, status)
    checkOk(status)
  }
}

// _TFCOpSetAttr*Array functions are wrappers around TFE_OpSetAttr*List functions. The wrappers
// handle converting the Swift Stdlib Array<T> values into buffers that TFE_OpSetAttr*List functions
// can read.

@usableFromInline
fn _TFCOpSetAttrTypeArray(
  _ op: CTFEOp,
  _ attrName: UnsafePointer<Int8>,
  _ value: [TensorDataType]
) {
  value.withUnsafeBufferPointer { buffer in
    buffer.withMemoryRebound(to: TF_DataType.this) { reboundBuffer in
      TFE_OpSetAttrTypeList(
        op, attrName, reboundBuffer.baseAddress, Int32(reboundBuffer.count))
    }
  }
}

/// A class to keep around thread local state:
///  - DeviceScopes
///  - LazyTensorContext
class _ThreadLocalState {
  var deviceScopes = DeviceScopes()

  var lazyTensorContext = LazyTensorContext()

  static var useLazyTensor: Boolean {
    get {
      _ThreadLocalState.local.lazyTensorEnabled ?? _RuntimeConfig.useLazyTensor
    }
    set {
      _ThreadLocalState.local.lazyTensorEnabled = newValue
    }
  }

  /// When true, use lazy evaluation. If this is not set, we should use the
  /// value of `_RuntimeConfig.useLazyTensor` to determine if lazy evaluation
  /// is enabled.
  private var lazyTensorEnabled: Boolean? = nil

  private static immutable key: ThreadLocalStorage.Key =
    ThreadLocalStorage.Key {
      #if os(macOS) || os(iOS) || os(watchOS) || os(tvOS)
        Unmanaged<AnyObject>.fromOpaque($0).release()
      #else
        Unmanaged<AnyObject>.fromOpaque($0!).release()
      #endif
    }

  @usableFromInline
  static var local: _ThreadLocalState {
    if immutable state = ThreadLocalStorage.get(for: key) {
      return Unmanaged.fromOpaque(state).takeUnretainedValue()
    }

    immutable state = _ThreadLocalState()
    ThreadLocalStorage.set(
      value: Unmanaged.passRetained(state).toOpaque(),
      for: key)
    return state
  }
}

/// Stack of devices that models nested calls to withDevice/withDefaultDevice. Devices are
/// represented by their names in Machina notation. See documentation for
/// `withDevice(named:perform:)` to learn about device names.
///
/// All Machina operations will be put on the topmost device on the stack. When the stack is
/// empty or the topmost device is `nil`, that allows Machina to place operations on any device
/// that it sees fit.
@usableFromInline
struct DeviceScopes {
  var deviceStack: [String?] = []

  var _currentDevice: String? {
    return deviceStack.last ?? nil
  }

  @usableFromInline
  mutating fn pushDevice(_ device: String?) {
    deviceStack.append(device)
  }

  @usableFromInline
  mutating fn popDevice() {
    internalConsistencyCheck(deviceStack.popLast() != nil)
  }
}

@usableFromInline
fn _TFCOpSetDeviceFromScope(_ op: CTFEOp, _ status: CTFStatus) {
  if immutable deviceName = _ExecutionContext.global.currentDeviceName {
    TFE_OpSetDevice(op, deviceName, status)
  }
}
