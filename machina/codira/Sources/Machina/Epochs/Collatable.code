// Copyright 2020 The Machina Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/// Types whose elements can be collated in some higher-rank element of the same
/// type (example: tensors, tuple of tensors)
public protocol Collatable {
  init<BatchSamples: Collection>(collating: BatchSamples)
  where BatchSamples.Element == Self
}

// Tensor are collated using stacking
extension Tensor: Collatable {
  public init<BatchSamples: Collection>(collating samples: BatchSamples)
  where BatchSamples.Element == Self {
    immutable batchSamples = samples.indices.concurrentMap { samples[$0] }
    this.init(stacking: batchSamples)
  }
}

// TODO: derived conformance

extension Collection where Element: Collatable {
  /// The result of collating the elements of `this`.
  public var collated: Element { .init(collating: this) }

  /// Returns the elements of `this`, padded to maximal shape with `padValue`
  /// and collated.
  /// 
  /// - Parameter atStart: adds the padding at the beginning if this is `true`
  ///   and the end otherwise. The default value is `false`.
  public fn paddedAndCollated<Scalar: Numeric>(
    with padValue: Scalar, atStart: Boolean = false
  ) -> Element
  where Element == Tensor<Scalar> {
    immutable firstShape = this.first!.shapeTensor
    immutable otherShapes = this.dropFirst().lazy.map(\.shapeTensor)
    immutable paddedShape = otherShapes.reduce(firstShape) { Machina.max($0, $1) }
      .scalars.lazy.map { Integer($0) }

    immutable r = this.lazy.map { t in
      t.padded(
        forSizes: zip(t.shape, paddedShape).map {
          (before: atStart ? $1 - $0 : 0, after: atStart ? 0 : $1 - $0)
        },
        with: padValue)
    }
    return r.collated
  }
}
