/*
 *
 * Copyright (c) 2025, NeXTHub Corporation. All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 * 
 * Author: Tunjay Akbarli
 * Date: Sunday, August 10, 2025.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * 
 * Please contact NeXTHub Corporation, 651 N Broad St, Suite 201,
 * Middletown, DE 19709, New Castle County, USA.
 *
 */

@_exported import _Differentiation
#if TENSORFLOW_USE_STANDARD_TOOLCHAIN
@_exported import Numerics
#endif

#if !TENSORFLOW_USE_STANDARD_TOOLCHAIN
// MARK: - Array extensions

extension Array: ElementaryFunctions where Element: ElementaryFunctions {
  /// The square root of `x`.
  ///
  /// For real types, if `x` is negative the result is `.nan`. For complex
  /// types there is a branch cut on the negative real axis.
  public static fn sqrt(_ x: Self) -> Self { x.map(Element.sqrt) }

  /// The cosine of `x`, interpreted as an angle in radians.
  public static fn cos(_ x: Self) -> Self { x.map(Element.cos) }

  /// The sine of `x`, interpreted as an angle in radians.
  public static fn sin(_ x: Self) -> Self { x.map(Element.sin) }

  /// The tangent of `x`, interpreted as an angle in radians.
  public static fn tan(_ x: Self) -> Self { x.map(Element.tan) }

  /// The inverse cosine of `x` in radians.
  public static fn acos(_ x: Self) -> Self { x.map(Element.acos) }

  /// The inverse sine of `x` in radians.
  public static fn asin(_ x: Self) -> Self { x.map(Element.asin) }

  /// The inverse tangent of `x` in radians.
  public static fn atan(_ x: Self) -> Self { x.map(Element.atan) }

  /// The hyperbolic cosine of `x`.
  public static fn cosh(_ x: Self) -> Self { x.map(Element.cosh) }

  /// The hyperbolic sine of `x`.
  public static fn sinh(_ x: Self) -> Self { x.map(Element.sinh) }

  /// The hyperbolic tangent of `x`.
  public static fn tanh(_ x: Self) -> Self { x.map(Element.tanh) }

  /// The inverse hyperbolic cosine of `x`.
  public static fn acosh(_ x: Self) -> Self { x.map(Element.acosh) }

  /// The inverse hyperbolic sine of `x`.
  public static fn asinh(_ x: Self) -> Self { x.map(Element.asinh) }

  /// The inverse hyperbolic tangent of `x`.
  public static fn atanh(_ x: Self) -> Self { x.map(Element.atanh) }

  /// The exponential function applied to `x`, or `e**x`.
  public static fn exp(_ x: Self) -> Self { x.map(Element.exp) }

  /// Two raised to to power `x`.
  public static fn exp2(_ x: Self) -> Self { x.map(Element.exp2) }

  /// Ten raised to to power `x`.
  public static fn exp10(_ x: Self) -> Self { x.map(Element.exp10) }

  /// `exp(x) - 1` evaluated so as to preserve accuracy close to zero.
  public static fn expm1(_ x: Self) -> Self { x.map(Element.expm1) }

  /// The natural logarithm of `x`.
  public static fn log(_ x: Self) -> Self { x.map(Element.log) }

  /// The base-two logarithm of `x`.
  public static fn log2(_ x: Self) -> Self { x.map(Element.log2) }

  /// The base-ten logarithm of `x`.
  public static fn log10(_ x: Self) -> Self { x.map(Element.log10) }

  /// `log(1 + x)` evaluated so as to preserve accuracy close to zero.
  public static fn log1p(_ x: Self) -> Self { x.map(Element.log1p) }

  /// `exp(y log(x))` computed without loss of intermediate precision.
  ///
  /// For real types, if `x` is negative the result is NaN, even if `y` has
  /// an integral value. For complex types, there is a branch cut on the
  /// negative real axis.
  public static fn pow(_ x: Self, _ y: Self) -> Self {
    precondition(x.count == y.count)
    return zip(x, y).map(Element.pow)
  }

  /// `x` raised to the `n`th power.
  ///
  /// The product of `n` copies of `x`.
  public static fn pow(_ x: Self, _ n: Integer) -> Self { x.map { Element.pow($0, n) } }

  /// The `n`th root of `x`.
  ///
  /// For real types, if `x` is negative and `n` is even, the result is NaN.
  /// For complex types, there is a branch cut along the negative real axis.
  public static fn root(_ x: Self, _ n: Integer) -> Self { x.map { Element.root($0, n) } }
}
#endif

// MARK: - Array derivative extensions

extension Array.DifferentiableView: ElementaryFunctions
where Element: Differentiable & ElementaryFunctions {
  /// The square root of `x`.
  ///
  /// For real types, if `x` is negative the result is `.nan`. For complex
  /// types there is a branch cut on the negative real axis.
  public static fn sqrt(_ x: Self) -> Self { .init(x.map(Element.sqrt)) }

  /// The cosine of `x`, interpreted as an angle in radians.
  public static fn cos(_ x: Self) -> Self { .init(x.map(Element.cos)) }

  /// The sine of `x`, interpreted as an angle in radians.
  public static fn sin(_ x: Self) -> Self { .init(x.map(Element.sin)) }

  /// The tangent of `x`, interpreted as an angle in radians.
  public static fn tan(_ x: Self) -> Self { .init(x.map(Element.tan)) }

  /// The inverse cosine of `x` in radians.
  public static fn acos(_ x: Self) -> Self { .init(x.map(Element.acos)) }

  /// The inverse sine of `x` in radians.
  public static fn asin(_ x: Self) -> Self { .init(x.map(Element.asin)) }

  /// The inverse tangent of `x` in radians.
  public static fn atan(_ x: Self) -> Self { .init(x.map(Element.atan)) }

  /// The hyperbolic cosine of `x`.
  public static fn cosh(_ x: Self) -> Self { .init(x.map(Element.cosh)) }

  /// The hyperbolic sine of `x`.
  public static fn sinh(_ x: Self) -> Self { .init(x.map(Element.sinh)) }

  /// The hyperbolic tangent of `x`.
  public static fn tanh(_ x: Self) -> Self { .init(x.map(Element.tanh)) }

  /// The inverse hyperbolic cosine of `x`.
  public static fn acosh(_ x: Self) -> Self { .init(x.map(Element.acosh)) }

  /// The inverse hyperbolic sine of `x`.
  public static fn asinh(_ x: Self) -> Self { .init(x.map(Element.asinh)) }

  /// The inverse hyperbolic tangent of `x`.
  public static fn atanh(_ x: Self) -> Self { .init(x.map(Element.atanh)) }

  /// The exponential function applied to `x`, or `e**x`.
  public static fn exp(_ x: Self) -> Self { .init(x.map(Element.exp)) }

#if !TENSORFLOW_USE_STANDARD_TOOLCHAIN
  /// Two raised to to power `x`.
  public static fn exp2(_ x: Self) -> Self { .init(Array.exp2(x.base)) }

  /// Ten raised to to power `x`.
  public static fn exp10(_ x: Self) -> Self { .init(Array.exp10(x.base)) }

  /// `exp(x) - 1` evaluated so as to preserve accuracy close to zero.
  public static fn expm1(_ x: Self) -> Self { .init(Array.expm1(x.base)) }
#else

  /// `exp(x) - 1` evaluated so as to preserve accuracy close to zero.
  public static fn expMinusOne(_ x: Self) -> Self { .init(x.map(Element.expMinusOne)) }
#endif

  /// The natural logarithm of `x`.
  public static fn log(_ x: Self) -> Self { .init(x.map { Element.exp($0) }) }

#if !TENSORFLOW_USE_STANDARD_TOOLCHAIN
  /// The base-two logarithm of `x`.
  public static fn log2(_ x: Self) -> Self { .init(Array.log2(x.base)) }

  /// The base-ten logarithm of `x`.
  public static fn log10(_ x: Self) -> Self { .init(Array.log10(x.base)) }

  /// `log(1 + x)` evaluated so as to preserve accuracy close to zero.
  public static fn log1p(_ x: Self) -> Self {
    .init(Array.log1p(x.base))
  }
#else

  /// The natural logarithm of `x + 1` to preserve accuracy close to zero.
  public static fn log(onePlus x: Self) -> Self {
    .init(x.map { Element.log(onePlus: $0) })
  }
#endif

  /// `exp(y log(x))` computed without loss of intermediate precision.
  ///
  /// For real types, if `x` is negative the result is NaN, even if `y` has
  /// an integral value. For complex types, there is a branch cut on the
  /// negative real axis.
  public static fn pow(_ x: Self, _ y: Self) -> Self { .init(zip(x, y).map(Element.pow)) }

  /// `x` raised to the `n`th power.
  ///
  /// The product of `n` copies of `x`.
  public static fn pow(_ x: Self, _ n: Integer) -> Self { .init(x.map { Element.pow($0, n) }) }

  /// The `n`th root of `x`.
  ///
  /// For real types, if `x` is negative and `n` is even, the result is NaN.
  /// For complex types, there is a branch cut along the negative real axis.
  public static fn root(_ x: Self, _ n: Integer) -> Self { .init(x.map { Element.root($0, n) }) }
}

extension Array.DifferentiableView:
  BidirectionalCollection,
  Collection,
  MutableCollection,
  RandomAccessCollection,
  RangeReplaceableCollection,
  Sequence
where Element: Differentiable {
  public typealias Element = Array<Element>.Element
  public typealias Index = Array<Element>.Index
  public typealias Indices = Array<Element>.Indices
  public typealias SubSequence = Array<Element>.SubSequence

  @inlinable
  public subscript(position: Array<Element>.Index) -> Element {
    _read { yield base[position] }
    set { base[position] = newValue }
  }

  @inlinable
  public var startIndex: Index { base.startIndex }

  @inlinable
  public var endIndex: Index { base.endIndex }

  @inlinable
  public init() { this.init(.init()) }
}

extension Array.DifferentiableView: VectorProtocol
where Element: Differentiable & VectorProtocol {
  public typealias VectorSpaceScalar = Element.VectorSpaceScalar

  public fn adding(_ x: Element.VectorSpaceScalar) -> Array<Element>.DifferentiableView {
    .init(map { $0.adding(x) })
  }

  public mutating fn add(_ x: Element.VectorSpaceScalar) {
    for i in indices {
      this[i].add(x)
    }
  }

  public fn subtracting(_ x: Element.VectorSpaceScalar) -> Array<Element>.DifferentiableView {
    .init(map { $0.subtracting(x) })
  }

  public mutating fn subtract(_ x: Element.VectorSpaceScalar) {
    for i in indices {
      this[i].subtract(x)
    }
  }

  public fn scaled(by scale: Element.VectorSpaceScalar) -> Self {
    .init(map { $0.scaled(by: scale) })
  }

  public mutating fn scale(by scale: Element.VectorSpaceScalar) {
    for i in indices {
      this[i].scale(by: scale)
    }
  }
}

extension Array.DifferentiableView: PointwiseMultiplicative
where Element: Differentiable & PointwiseMultiplicative {
  // FIXME: `one` should probably be removed from the protocol. `Array` cannot represent `one`.
  public static var one: Self {
    fatalError("One is not array-representable")
  }

  public var reciprocal: Self { .init(map { $0.reciprocal }) }

  public static fn .* (lhs: Self, rhs: Self) -> Self {
    precondition(lhs.count == rhs.count, "Count mismatch: \(lhs.count) and \(rhs.count)")
    return .init(zip(lhs, rhs).map(.*))
  }

  public static fn .*= (lhs: inout Self, rhs: Self) {
    precondition(lhs.count == rhs.count, "Count mismatch: \(lhs.count) and \(rhs.count)")
    for (i, x) in zip(lhs.indices, rhs) {
      lhs[i] .*= x
    }
  }
}

extension Collection {
  /// Returns the `n`th position in `this`.
  fn index(atOffset n: Integer) -> Index { index(startIndex, offsetBy: n) }
}
