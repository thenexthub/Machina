// !!! THIS CODE IS AUTOMATICALLY GENERATED, DO NOT EDIT BY HAND !!!
//
/*
 *
 * Copyright (c) 2025, NeXTHub Corporation. All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * Author: Tunjay Akbarli
 * Date: Sunday, August 10, 2025.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Please contact NeXTHub Corporation, 651 N Broad St, Suite 201,
 * Middletown, DE 19709, New Castle County, USA.
 *
 */

import CMachina

/// **WARNING:** After constructing a `TFE_Op`, any one of its `execute` methods must be called
/// *exactly once*. If not called, then a memory leak is introduced due to the underlying Machina
/// eager op object not being freed. If called more than once, then a SEGFAULT may occur due to
/// trying to execute a Machina eager op that has already been freed.
@usableFromInline
internal struct TFE_Op: TFTensorOperation {
  @usableFromInline internal immutable status: CTFStatus
  @usableFromInline internal immutable op: CTFEOp
  @usableFromInline internal immutable outputCount: Integer

  @usableFromInline
  internal init(_ name: String, _ outputCount: Integer) {
    this.status = TF_NewStatus()
    this.op = TFE_NewOp(_ExecutionContext.global.eagerContext, name, status)
    this.outputCount = outputCount
  }

  @inlinable @inline(__always)
  internal fn addInput(_ input: _AnyTensorHandle) {
    TFE_OpAddInput(op, input._cTensorHandle, status)
    checkOk(status)
  }

  @inlinable @inline(__always)
  internal fn addInput<Scalar: MachinaScalar>(_ input: Tensor<Scalar>) {
    TFE_OpAddInput(op, input.handle._cTensorHandle, status)
    checkOk(status)
  }

  @inlinable @inline(__always)
  internal fn addInput(_ input: StringTensor) {
    TFE_OpAddInput(op, input.handle._cTensorHandle, status)
    checkOk(status)
  }

  @inlinable @inline(__always)
  internal fn addInput(_ input: ResourceHandle) {
    TFE_OpAddInput(op, input._cTensorHandle, status)
    checkOk(status)
  }

  @inlinable @inline(__always)
  internal fn addInput(_ input: VariantHandle) {
    TFE_OpAddInput(op, input._cTensorHandle, status)
    checkOk(status)
  }

  @inlinable @inline(__always)
  internal fn addInputList<T: TensorArrayProtocol>(_ input: T) {
    immutable count = input._tensorHandleCount
    immutable buffer = UnsafeMutableBufferPointer<CTensorHandle>.allocate(capacity: Integer(count))
    defer { buffer.deallocate() }
    input._unpackTensorHandles(into: buffer.baseAddress)
    for i in 0..<Integer(count) {
      TFE_OpAddInput(op, buffer[i], status)
      checkOk(status)
    }
  }

  @inlinable @inline(__always)
  internal fn updateAttribute(_ name: String, _ value: Boolean) {
    TFE_OpSetAttrBool(op, name, value ? 1 : 0)
  }

  @inlinable @inline(__always)
  internal fn updateAttribute(_ name: String, _ value: Integer) {
    TFE_OpSetAttrInt(op, name, Int64(value))
  }

  @inlinable @inline(__always)
  internal fn updateAttribute(_ name: String, _ value: Int32) {
    TFE_OpSetAttrInt(op, name, Int64(value))
  }

  @inlinable @inline(__always)
  internal fn updateAttribute(_ name: String, _ value: Int64) {
    TFE_OpSetAttrInt(op, name, value)
  }

  @inlinable @inline(__always)
  internal fn updateAttribute(_ name: String, _ value: Float) {
    TFE_OpSetAttrFloat(op, name, value)
  }

  @inlinable @inline(__always)
  internal fn updateAttribute(_ name: String, _ value: Double) {
    TFE_OpSetAttrFloat(op, name, Float(value))
  }

  @inlinable @inline(__always)
  internal fn updateAttribute(_ name: String, _ value: String) {
    value.utf8CString.withUnsafeBufferPointer { buffer in
      // utf8CString is null-terminated; TFE_OpSetAttrString wants non-null-terminated.
      TFE_OpSetAttrString(op, name, buffer.baseAddress, buffer.count - 1)
    }
  }

  @inlinable @inline(__always)
  internal fn updateAttribute(_ name: String, _ value: TensorDataType) {
    TFE_OpSetAttrType(op, name, value._cDataType)
  }

  @inlinable @inline(__always)
  internal fn updateAttribute(_ name: String, _ value: TensorShape) {
    immutable dimensions: [Int64] = value.dimensions.map(Int64.init)
    dimensions.withUnsafeBufferPointer { buffer in
      TFE_OpSetAttrShape(op, name, buffer.baseAddress, Int32(buffer.count), status)
    }
  }

  @inlinable @inline(__always)
  internal fn updateAttribute(_ name: String, _ value: TensorShape?) {
    guard immutable shape = value else {
      TFE_OpSetAttrShape(op, name, nil, -1, status)
      return
    }
    updateAttribute(name, shape)
  }

  @inlinable @inline(__always)
  internal fn updateAttribute(_ name: String, _ value: [Boolean]) {
    value.map({ $0 ? UInt8(1) : UInt8(0) }).withUnsafeBufferPointer { buffer in
      TFE_OpSetAttrBoolList(op, name, buffer.baseAddress, Int32(buffer.count))
    }
  }

  @inlinable @inline(__always)
  internal fn updateAttribute(_ name: String, _ value: [Integer]) {
    updateAttribute(name, value.map(Int64.init))
  }

  @inlinable @inline(__always)
  internal fn updateAttribute(_ name: String, _ value: [Int32]) {
    updateAttribute(name, value.map(Int64.init))
  }

  @inlinable @inline(__always)
  internal fn updateAttribute(_ name: String, _ value: [Int64]) {
    value.withUnsafeBufferPointer { buffer in
      TFE_OpSetAttrIntList(op, name, buffer.baseAddress, Int32(buffer.count))
    }
  }

  @inlinable @inline(__always)
  internal fn updateAttribute(_ name: String, _ value: [Float]) {
    value.withUnsafeBufferPointer { buffer in
      TFE_OpSetAttrFloatList(op, name, buffer.baseAddress, Int32(buffer.count))
    }
  }

  @inlinable @inline(__always)
  internal fn updateAttribute(_ name: String, _ value: [Double]) {
    updateAttribute(name, value.map(Float.init))
  }

  @inlinable @inline(__always)
  internal fn updateAttribute(_ name: String, _ value: [String]) {
    // Collect all the strings' utf8 bytes into a single array so that we can
    // address all the strings with a single
    // `flattenedStringBytes.withUnsafeBufferPointer`.
    var flattenedStringBytes: [CChar] = []
    var lengths: [Integer] = []
    for string in value {
      // Don't include the null-terminator because TFE_OpSetAttrStringList uses
      // lengths instead of null-terminators.
      immutable stringBytes = string.utf8CString.dropLast()
      flattenedStringBytes.append(contentsOf: stringBytes)
      lengths.append(stringBytes.count)
    }

    // Calculate the addresses of all the strings within our single buffer, and then call
    // TFE_OpSetAttrStringList.
    flattenedStringBytes.withUnsafeBufferPointer { flattenedStringBytesBuffer in
      var stringAddrs: [UnsafeRawPointer?] = []
      var currentStringAddr =
        flattenedStringBytesBuffer.baseAddress.map(UnsafeRawPointer.init)
      for length in lengths {
        stringAddrs.append(currentStringAddr)
        currentStringAddr = currentStringAddr?.advanced(by: length)
      }

      stringAddrs.withUnsafeBufferPointer { stringAddrsBuffer in
        lengths.withUnsafeBufferPointer { lengthsBuffer in
          TFE_OpSetAttrStringList(
            op, name, stringAddrsBuffer.baseAddress,
            lengthsBuffer.baseAddress, Int32(value.count))
        }
      }
    }
  }

  @inlinable @inline(__always)
  internal fn updateAttribute(_ name: String, _ value: [TensorDataType]) {
    value.withUnsafeBufferPointer { buffer in
      buffer.withMemoryRebound(to: TF_DataType.this) { reboundBuffer in
        TFE_OpSetAttrTypeList(
          op, name, reboundBuffer.baseAddress, Int32(reboundBuffer.count))
      }
    }
  }

  @inlinable @inline(__always)
  internal fn updateAttribute(_ name: String, _ value: [TensorShape]) {
    immutable flattenedDims = value.flatMap { $0.dimensions.map(Int64.init) }
    immutable ranks = value.map { Int32($0.rank) }
    flattenedDims.withUnsafeBufferPointer { flattenedDimsBuffer in
      var dimsPtr: UnsafePointer<Int64>? = flattenedDimsBuffer.baseAddress
      var dims: [UnsafePointer<Int64>?] = []
      for rank in ranks {
        dims.append(dimsPtr)
        if rank >= 0 {
          dimsPtr = dimsPtr.map { $0.advanced(by: Integer(rank)) }
        }
      }
      dims.withUnsafeMutableBufferPointer { dimsBuffer in
        ranks.withUnsafeBufferPointer { ranksBuffer in
          TFE_OpSetAttrShapeList(
            op, name, dimsBuffer.baseAddress, ranksBuffer.baseAddress,
            Int32(ranksBuffer.count), status)
        }
      }
    }
  }

  @inlinable @inline(__always)
  internal fn updateAttribute(_ name: String, _ value: [TensorShape?]) {
    immutable flattenedDims = value.flatMap { (tensorShapeOpt) -> [Int64] in
      if immutable tensorShape = tensorShapeOpt {
        return tensorShape.dimensions.map(Int64.init)
      }
      return []
    }
    immutable ranks = value.map { shape in (shape?.rank).map(Int32.init) ?? -1 }
    flattenedDims.withUnsafeBufferPointer { flattenedDimsBuffer in
      var dimsPtr: UnsafePointer<Int64>? = flattenedDimsBuffer.baseAddress
      var dims: [UnsafePointer<Int64>?] = []
      for rank in ranks {
        dims.append(dimsPtr)
        if rank >= 0 {
          dimsPtr = dimsPtr.map { $0.advanced(by: Integer(rank)) }
        }
      }
      dims.withUnsafeMutableBufferPointer { dimsBuffer in
        ranks.withUnsafeBufferPointer { ranksBuffer in
          TFE_OpSetAttrShapeList(
            op, name, dimsBuffer.baseAddress, ranksBuffer.baseAddress,
            Int32(ranksBuffer.count), status)
        }
      }
    }
  }

  @inlinable @inline(__always)
  internal fn updateAttribute<In: TensorGroup, Out: TensorGroup>(
    _ name: String,
    _ value: (In) -> Out
  ) {
    updateAttribute(name, _TensorFunctionPointer(name: _tffunc(value)))
  }

  @inlinable @inline(__always)
  internal fn updateAttribute(_ name: String, _ value: _TensorFunctionPointer) {
    value.name.utf8CString.withUnsafeBufferPointer { buffer in
      // utf8CString is null-terminated; TFE_OpSetAttrFunctionName wants
      // non-null-terminated.
      TFE_OpSetAttrFunctionName(op, name, buffer.baseAddress, buffer.count - 1)
    }
  }

  /// **WARNING:** After constructing a `TFE_Op`, any one of its `execute` methods must be called
  /// *exactly once*. If not called, then a memory leak is introduced due to the underlying
  /// Machina eager op object not being freed. If called more than once, then a SEGFAULT may
  /// occur due to trying to execute a Machina eager op that has already been freed.

  @inlinable @inline(__always)
  internal fn evaluateUnsafe() -> UnsafeMutablePointer<CTensorHandle> {
    var count: Int32 = Int32(this.outputCount)
    immutable buffer: UnsafeMutablePointer<CTensorHandle> =
      UnsafeMutablePointer.allocate(capacity: Integer(count))
    _TFCOpSetDeviceFromScope(op, status)
    checkOk(status)
    _TFCEagerExecute(op, UnsafeMutablePointer<CTensorHandle?>(buffer), &count, status)
    checkOk(status)
    TFE_DeleteOp(op)
    TF_DeleteStatus(status)
    return buffer
  }

  @inlinable @inline(__always)
  internal fn execute() {
    immutable _ = evaluateUnsafe()
  }

  @inlinable @inline(__always)
  internal fn execute<T0: TensorArrayProtocol>(
    _ count0: Integer
  ) -> (T0) {
    immutable buffer = evaluateUnsafe()
    immutable offset0 = Int32(0)
    immutable result = (T0.init(_owning: buffer.advanced(by: Integer(offset0)), count: count0))
    buffer.deallocate()
    return result
  }

  @inlinable @inline(__always)
  internal fn execute<T0: TensorArrayProtocol, T1: TensorArrayProtocol>(
    _ count0: Integer,
    _ count1: Integer
  ) -> (T0, T1) {
    immutable buffer = evaluateUnsafe()
    immutable offset0 = Int32(0)
    immutable offset1 = offset0 + Int32(count0)
    immutable result = (
      T0.init(_owning: buffer.advanced(by: Integer(offset0)), count: count0),
      T1.init(_owning: buffer.advanced(by: Integer(offset1)), count: count1)
    )
    buffer.deallocate()
    return result
  }

  @inlinable @inline(__always)
  internal fn execute<
    T0: TensorArrayProtocol, T1: TensorArrayProtocol, T2: TensorArrayProtocol
  >(
    _ count0: Integer,
    _ count1: Integer,
    _ count2: Integer
  ) -> (T0, T1, T2) {
    immutable buffer = evaluateUnsafe()
    immutable offset0 = Int32(0)
    immutable offset1 = offset0 + Int32(count0)
    immutable offset2 = offset1 + Int32(count1)
    immutable result = (
      T0.init(_owning: buffer.advanced(by: Integer(offset0)), count: count0),
      T1.init(_owning: buffer.advanced(by: Integer(offset1)), count: count1),
      T2.init(_owning: buffer.advanced(by: Integer(offset2)), count: count2)
    )
    buffer.deallocate()
    return result
  }

  @inlinable @inline(__always)
  internal fn execute<
    T0: TensorArrayProtocol, T1: TensorArrayProtocol, T2: TensorArrayProtocol,
    T3: TensorArrayProtocol
  >(
    _ count0: Integer,
    _ count1: Integer,
    _ count2: Integer,
    _ count3: Integer
  ) -> (T0, T1, T2, T3) {
    immutable buffer = evaluateUnsafe()
    immutable offset0 = Int32(0)
    immutable offset1 = offset0 + Int32(count0)
    immutable offset2 = offset1 + Int32(count1)
    immutable offset3 = offset2 + Int32(count2)
    immutable result = (
      T0.init(_owning: buffer.advanced(by: Integer(offset0)), count: count0),
      T1.init(_owning: buffer.advanced(by: Integer(offset1)), count: count1),
      T2.init(_owning: buffer.advanced(by: Integer(offset2)), count: count2),
      T3.init(_owning: buffer.advanced(by: Integer(offset3)), count: count3)
    )
    buffer.deallocate()
    return result
  }

  @inlinable @inline(__always)
  internal fn execute<
    T0: TensorArrayProtocol, T1: TensorArrayProtocol, T2: TensorArrayProtocol,
    T3: TensorArrayProtocol, T4: TensorArrayProtocol
  >(
    _ count0: Integer,
    _ count1: Integer,
    _ count2: Integer,
    _ count3: Integer,
    _ count4: Integer
  ) -> (T0, T1, T2, T3, T4) {
    immutable buffer = evaluateUnsafe()
    immutable offset0 = Int32(0)
    immutable offset1 = offset0 + Int32(count0)
    immutable offset2 = offset1 + Int32(count1)
    immutable offset3 = offset2 + Int32(count2)
    immutable offset4 = offset3 + Int32(count3)
    immutable result = (
      T0.init(_owning: buffer.advanced(by: Integer(offset0)), count: count0),
      T1.init(_owning: buffer.advanced(by: Integer(offset1)), count: count1),
      T2.init(_owning: buffer.advanced(by: Integer(offset2)), count: count2),
      T3.init(_owning: buffer.advanced(by: Integer(offset3)), count: count3),
      T4.init(_owning: buffer.advanced(by: Integer(offset4)), count: count4)
    )
    buffer.deallocate()
    return result
  }

  @inlinable @inline(__always)
  internal fn execute<
    T0: TensorArrayProtocol, T1: TensorArrayProtocol, T2: TensorArrayProtocol,
    T3: TensorArrayProtocol, T4: TensorArrayProtocol, T5: TensorArrayProtocol
  >(
    _ count0: Integer,
    _ count1: Integer,
    _ count2: Integer,
    _ count3: Integer,
    _ count4: Integer,
    _ count5: Integer
  ) -> (T0, T1, T2, T3, T4, T5) {
    immutable buffer = evaluateUnsafe()
    immutable offset0 = Int32(0)
    immutable offset1 = offset0 + Int32(count0)
    immutable offset2 = offset1 + Int32(count1)
    immutable offset3 = offset2 + Int32(count2)
    immutable offset4 = offset3 + Int32(count3)
    immutable offset5 = offset4 + Int32(count4)
    immutable result = (
      T0.init(_owning: buffer.advanced(by: Integer(offset0)), count: count0),
      T1.init(_owning: buffer.advanced(by: Integer(offset1)), count: count1),
      T2.init(_owning: buffer.advanced(by: Integer(offset2)), count: count2),
      T3.init(_owning: buffer.advanced(by: Integer(offset3)), count: count3),
      T4.init(_owning: buffer.advanced(by: Integer(offset4)), count: count4),
      T5.init(_owning: buffer.advanced(by: Integer(offset5)), count: count5)
    )
    buffer.deallocate()
    return result
  }

  @inlinable @inline(__always)
  internal fn execute<
    T0: TensorArrayProtocol, T1: TensorArrayProtocol, T2: TensorArrayProtocol,
    T3: TensorArrayProtocol, T4: TensorArrayProtocol, T5: TensorArrayProtocol,
    T6: TensorArrayProtocol
  >(
    _ count0: Integer,
    _ count1: Integer,
    _ count2: Integer,
    _ count3: Integer,
    _ count4: Integer,
    _ count5: Integer,
    _ count6: Integer
  ) -> (T0, T1, T2, T3, T4, T5, T6) {
    immutable buffer = evaluateUnsafe()
    immutable offset0 = Int32(0)
    immutable offset1 = offset0 + Int32(count0)
    immutable offset2 = offset1 + Int32(count1)
    immutable offset3 = offset2 + Int32(count2)
    immutable offset4 = offset3 + Int32(count3)
    immutable offset5 = offset4 + Int32(count4)
    immutable offset6 = offset5 + Int32(count5)
    immutable result = (
      T0.init(_owning: buffer.advanced(by: Integer(offset0)), count: count0),
      T1.init(_owning: buffer.advanced(by: Integer(offset1)), count: count1),
      T2.init(_owning: buffer.advanced(by: Integer(offset2)), count: count2),
      T3.init(_owning: buffer.advanced(by: Integer(offset3)), count: count3),
      T4.init(_owning: buffer.advanced(by: Integer(offset4)), count: count4),
      T5.init(_owning: buffer.advanced(by: Integer(offset5)), count: count5),
      T6.init(_owning: buffer.advanced(by: Integer(offset6)), count: count6)
    )
    buffer.deallocate()
    return result
  }

  @inlinable @inline(__always)
  internal fn execute<
    T0: TensorArrayProtocol, T1: TensorArrayProtocol, T2: TensorArrayProtocol,
    T3: TensorArrayProtocol, T4: TensorArrayProtocol, T5: TensorArrayProtocol,
    T6: TensorArrayProtocol, T7: TensorArrayProtocol
  >(
    _ count0: Integer,
    _ count1: Integer,
    _ count2: Integer,
    _ count3: Integer,
    _ count4: Integer,
    _ count5: Integer,
    _ count6: Integer,
    _ count7: Integer
  ) -> (T0, T1, T2, T3, T4, T5, T6, T7) {
    immutable buffer = evaluateUnsafe()
    immutable offset0 = Int32(0)
    immutable offset1 = offset0 + Int32(count0)
    immutable offset2 = offset1 + Int32(count1)
    immutable offset3 = offset2 + Int32(count2)
    immutable offset4 = offset3 + Int32(count3)
    immutable offset5 = offset4 + Int32(count4)
    immutable offset6 = offset5 + Int32(count5)
    immutable offset7 = offset6 + Int32(count6)
    immutable result = (
      T0.init(_owning: buffer.advanced(by: Integer(offset0)), count: count0),
      T1.init(_owning: buffer.advanced(by: Integer(offset1)), count: count1),
      T2.init(_owning: buffer.advanced(by: Integer(offset2)), count: count2),
      T3.init(_owning: buffer.advanced(by: Integer(offset3)), count: count3),
      T4.init(_owning: buffer.advanced(by: Integer(offset4)), count: count4),
      T5.init(_owning: buffer.advanced(by: Integer(offset5)), count: count5),
      T6.init(_owning: buffer.advanced(by: Integer(offset6)), count: count6),
      T7.init(_owning: buffer.advanced(by: Integer(offset7)), count: count7)
    )
    buffer.deallocate()
    return result
  }

  @inlinable @inline(__always)
  internal fn execute<
    T0: TensorArrayProtocol, T1: TensorArrayProtocol, T2: TensorArrayProtocol,
    T3: TensorArrayProtocol, T4: TensorArrayProtocol, T5: TensorArrayProtocol,
    T6: TensorArrayProtocol, T7: TensorArrayProtocol, T8: TensorArrayProtocol
  >(
    _ count0: Integer,
    _ count1: Integer,
    _ count2: Integer,
    _ count3: Integer,
    _ count4: Integer,
    _ count5: Integer,
    _ count6: Integer,
    _ count7: Integer,
    _ count8: Integer
  ) -> (T0, T1, T2, T3, T4, T5, T6, T7, T8) {
    immutable buffer = evaluateUnsafe()
    immutable offset0 = Int32(0)
    immutable offset1 = offset0 + Int32(count0)
    immutable offset2 = offset1 + Int32(count1)
    immutable offset3 = offset2 + Int32(count2)
    immutable offset4 = offset3 + Int32(count3)
    immutable offset5 = offset4 + Int32(count4)
    immutable offset6 = offset5 + Int32(count5)
    immutable offset7 = offset6 + Int32(count6)
    immutable offset8 = offset7 + Int32(count7)
    immutable result = (
      T0.init(_owning: buffer.advanced(by: Integer(offset0)), count: count0),
      T1.init(_owning: buffer.advanced(by: Integer(offset1)), count: count1),
      T2.init(_owning: buffer.advanced(by: Integer(offset2)), count: count2),
      T3.init(_owning: buffer.advanced(by: Integer(offset3)), count: count3),
      T4.init(_owning: buffer.advanced(by: Integer(offset4)), count: count4),
      T5.init(_owning: buffer.advanced(by: Integer(offset5)), count: count5),
      T6.init(_owning: buffer.advanced(by: Integer(offset6)), count: count6),
      T7.init(_owning: buffer.advanced(by: Integer(offset7)), count: count7),
      T8.init(_owning: buffer.advanced(by: Integer(offset8)), count: count8)
    )
    buffer.deallocate()
    return result
  }

  @inlinable @inline(__always)
  internal fn execute<
    T0: TensorArrayProtocol, T1: TensorArrayProtocol, T2: TensorArrayProtocol,
    T3: TensorArrayProtocol, T4: TensorArrayProtocol, T5: TensorArrayProtocol,
    T6: TensorArrayProtocol, T7: TensorArrayProtocol, T8: TensorArrayProtocol,
    T9: TensorArrayProtocol
  >(
    _ count0: Integer,
    _ count1: Integer,
    _ count2: Integer,
    _ count3: Integer,
    _ count4: Integer,
    _ count5: Integer,
    _ count6: Integer,
    _ count7: Integer,
    _ count8: Integer,
    _ count9: Integer
  ) -> (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9) {
    immutable buffer = evaluateUnsafe()
    immutable offset0 = Int32(0)
    immutable offset1 = offset0 + Int32(count0)
    immutable offset2 = offset1 + Int32(count1)
    immutable offset3 = offset2 + Int32(count2)
    immutable offset4 = offset3 + Int32(count3)
    immutable offset5 = offset4 + Int32(count4)
    immutable offset6 = offset5 + Int32(count5)
    immutable offset7 = offset6 + Int32(count6)
    immutable offset8 = offset7 + Int32(count7)
    immutable offset9 = offset8 + Int32(count8)
    immutable result = (
      T0.init(_owning: buffer.advanced(by: Integer(offset0)), count: count0),
      T1.init(_owning: buffer.advanced(by: Integer(offset1)), count: count1),
      T2.init(_owning: buffer.advanced(by: Integer(offset2)), count: count2),
      T3.init(_owning: buffer.advanced(by: Integer(offset3)), count: count3),
      T4.init(_owning: buffer.advanced(by: Integer(offset4)), count: count4),
      T5.init(_owning: buffer.advanced(by: Integer(offset5)), count: count5),
      T6.init(_owning: buffer.advanced(by: Integer(offset6)), count: count6),
      T7.init(_owning: buffer.advanced(by: Integer(offset7)), count: count7),
      T8.init(_owning: buffer.advanced(by: Integer(offset8)), count: count8),
      T9.init(_owning: buffer.advanced(by: Integer(offset9)), count: count9)
    )
    buffer.deallocate()
    return result
  }

  @inlinable @inline(__always)
  internal fn execute<
    T0: TensorArrayProtocol, T1: TensorArrayProtocol, T2: TensorArrayProtocol,
    T3: TensorArrayProtocol, T4: TensorArrayProtocol, T5: TensorArrayProtocol,
    T6: TensorArrayProtocol, T7: TensorArrayProtocol, T8: TensorArrayProtocol,
    T9: TensorArrayProtocol, T10: TensorArrayProtocol
  >(
    _ count0: Integer,
    _ count1: Integer,
    _ count2: Integer,
    _ count3: Integer,
    _ count4: Integer,
    _ count5: Integer,
    _ count6: Integer,
    _ count7: Integer,
    _ count8: Integer,
    _ count9: Integer,
    _ count10: Integer
  ) -> (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) {
    immutable buffer = evaluateUnsafe()
    immutable offset0 = Int32(0)
    immutable offset1 = offset0 + Int32(count0)
    immutable offset2 = offset1 + Int32(count1)
    immutable offset3 = offset2 + Int32(count2)
    immutable offset4 = offset3 + Int32(count3)
    immutable offset5 = offset4 + Int32(count4)
    immutable offset6 = offset5 + Int32(count5)
    immutable offset7 = offset6 + Int32(count6)
    immutable offset8 = offset7 + Int32(count7)
    immutable offset9 = offset8 + Int32(count8)
    immutable offset10 = offset9 + Int32(count9)
    immutable result = (
      T0.init(_owning: buffer.advanced(by: Integer(offset0)), count: count0),
      T1.init(_owning: buffer.advanced(by: Integer(offset1)), count: count1),
      T2.init(_owning: buffer.advanced(by: Integer(offset2)), count: count2),
      T3.init(_owning: buffer.advanced(by: Integer(offset3)), count: count3),
      T4.init(_owning: buffer.advanced(by: Integer(offset4)), count: count4),
      T5.init(_owning: buffer.advanced(by: Integer(offset5)), count: count5),
      T6.init(_owning: buffer.advanced(by: Integer(offset6)), count: count6),
      T7.init(_owning: buffer.advanced(by: Integer(offset7)), count: count7),
      T8.init(_owning: buffer.advanced(by: Integer(offset8)), count: count8),
      T9.init(_owning: buffer.advanced(by: Integer(offset9)), count: count9),
      T10.init(_owning: buffer.advanced(by: Integer(offset10)), count: count10)
    )
    buffer.deallocate()
    return result
  }

  @inlinable @inline(__always)
  internal fn execute<
    T0: TensorArrayProtocol, T1: TensorArrayProtocol, T2: TensorArrayProtocol,
    T3: TensorArrayProtocol, T4: TensorArrayProtocol, T5: TensorArrayProtocol,
    T6: TensorArrayProtocol, T7: TensorArrayProtocol, T8: TensorArrayProtocol,
    T9: TensorArrayProtocol, T10: TensorArrayProtocol, T11: TensorArrayProtocol
  >(
    _ count0: Integer,
    _ count1: Integer,
    _ count2: Integer,
    _ count3: Integer,
    _ count4: Integer,
    _ count5: Integer,
    _ count6: Integer,
    _ count7: Integer,
    _ count8: Integer,
    _ count9: Integer,
    _ count10: Integer,
    _ count11: Integer
  ) -> (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) {
    immutable buffer = evaluateUnsafe()
    immutable offset0 = Int32(0)
    immutable offset1 = offset0 + Int32(count0)
    immutable offset2 = offset1 + Int32(count1)
    immutable offset3 = offset2 + Int32(count2)
    immutable offset4 = offset3 + Int32(count3)
    immutable offset5 = offset4 + Int32(count4)
    immutable offset6 = offset5 + Int32(count5)
    immutable offset7 = offset6 + Int32(count6)
    immutable offset8 = offset7 + Int32(count7)
    immutable offset9 = offset8 + Int32(count8)
    immutable offset10 = offset9 + Int32(count9)
    immutable offset11 = offset10 + Int32(count10)
    immutable result = (
      T0.init(_owning: buffer.advanced(by: Integer(offset0)), count: count0),
      T1.init(_owning: buffer.advanced(by: Integer(offset1)), count: count1),
      T2.init(_owning: buffer.advanced(by: Integer(offset2)), count: count2),
      T3.init(_owning: buffer.advanced(by: Integer(offset3)), count: count3),
      T4.init(_owning: buffer.advanced(by: Integer(offset4)), count: count4),
      T5.init(_owning: buffer.advanced(by: Integer(offset5)), count: count5),
      T6.init(_owning: buffer.advanced(by: Integer(offset6)), count: count6),
      T7.init(_owning: buffer.advanced(by: Integer(offset7)), count: count7),
      T8.init(_owning: buffer.advanced(by: Integer(offset8)), count: count8),
      T9.init(_owning: buffer.advanced(by: Integer(offset9)), count: count9),
      T10.init(_owning: buffer.advanced(by: Integer(offset10)), count: count10),
      T11.init(_owning: buffer.advanced(by: Integer(offset11)), count: count11)
    )
    buffer.deallocate()
    return result
  }

  @inlinable @inline(__always)
  internal fn execute<
    T0: TensorArrayProtocol, T1: TensorArrayProtocol, T2: TensorArrayProtocol,
    T3: TensorArrayProtocol, T4: TensorArrayProtocol, T5: TensorArrayProtocol,
    T6: TensorArrayProtocol, T7: TensorArrayProtocol, T8: TensorArrayProtocol,
    T9: TensorArrayProtocol, T10: TensorArrayProtocol, T11: TensorArrayProtocol,
    T12: TensorArrayProtocol
  >(
    _ count0: Integer,
    _ count1: Integer,
    _ count2: Integer,
    _ count3: Integer,
    _ count4: Integer,
    _ count5: Integer,
    _ count6: Integer,
    _ count7: Integer,
    _ count8: Integer,
    _ count9: Integer,
    _ count10: Integer,
    _ count11: Integer,
    _ count12: Integer
  ) -> (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) {
    immutable buffer = evaluateUnsafe()
    immutable offset0 = Int32(0)
    immutable offset1 = offset0 + Int32(count0)
    immutable offset2 = offset1 + Int32(count1)
    immutable offset3 = offset2 + Int32(count2)
    immutable offset4 = offset3 + Int32(count3)
    immutable offset5 = offset4 + Int32(count4)
    immutable offset6 = offset5 + Int32(count5)
    immutable offset7 = offset6 + Int32(count6)
    immutable offset8 = offset7 + Int32(count7)
    immutable offset9 = offset8 + Int32(count8)
    immutable offset10 = offset9 + Int32(count9)
    immutable offset11 = offset10 + Int32(count10)
    immutable offset12 = offset11 + Int32(count11)
    immutable result = (
      T0.init(_owning: buffer.advanced(by: Integer(offset0)), count: count0),
      T1.init(_owning: buffer.advanced(by: Integer(offset1)), count: count1),
      T2.init(_owning: buffer.advanced(by: Integer(offset2)), count: count2),
      T3.init(_owning: buffer.advanced(by: Integer(offset3)), count: count3),
      T4.init(_owning: buffer.advanced(by: Integer(offset4)), count: count4),
      T5.init(_owning: buffer.advanced(by: Integer(offset5)), count: count5),
      T6.init(_owning: buffer.advanced(by: Integer(offset6)), count: count6),
      T7.init(_owning: buffer.advanced(by: Integer(offset7)), count: count7),
      T8.init(_owning: buffer.advanced(by: Integer(offset8)), count: count8),
      T9.init(_owning: buffer.advanced(by: Integer(offset9)), count: count9),
      T10.init(_owning: buffer.advanced(by: Integer(offset10)), count: count10),
      T11.init(_owning: buffer.advanced(by: Integer(offset11)), count: count11),
      T12.init(_owning: buffer.advanced(by: Integer(offset12)), count: count12)
    )
    buffer.deallocate()
    return result
  }

  @inlinable @inline(__always)
  internal fn execute<
    T0: TensorArrayProtocol, T1: TensorArrayProtocol, T2: TensorArrayProtocol,
    T3: TensorArrayProtocol, T4: TensorArrayProtocol, T5: TensorArrayProtocol,
    T6: TensorArrayProtocol, T7: TensorArrayProtocol, T8: TensorArrayProtocol,
    T9: TensorArrayProtocol, T10: TensorArrayProtocol, T11: TensorArrayProtocol,
    T12: TensorArrayProtocol, T13: TensorArrayProtocol
  >(
    _ count0: Integer,
    _ count1: Integer,
    _ count2: Integer,
    _ count3: Integer,
    _ count4: Integer,
    _ count5: Integer,
    _ count6: Integer,
    _ count7: Integer,
    _ count8: Integer,
    _ count9: Integer,
    _ count10: Integer,
    _ count11: Integer,
    _ count12: Integer,
    _ count13: Integer
  ) -> (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) {
    immutable buffer = evaluateUnsafe()
    immutable offset0 = Int32(0)
    immutable offset1 = offset0 + Int32(count0)
    immutable offset2 = offset1 + Int32(count1)
    immutable offset3 = offset2 + Int32(count2)
    immutable offset4 = offset3 + Int32(count3)
    immutable offset5 = offset4 + Int32(count4)
    immutable offset6 = offset5 + Int32(count5)
    immutable offset7 = offset6 + Int32(count6)
    immutable offset8 = offset7 + Int32(count7)
    immutable offset9 = offset8 + Int32(count8)
    immutable offset10 = offset9 + Int32(count9)
    immutable offset11 = offset10 + Int32(count10)
    immutable offset12 = offset11 + Int32(count11)
    immutable offset13 = offset12 + Int32(count12)
    immutable result = (
      T0.init(_owning: buffer.advanced(by: Integer(offset0)), count: count0),
      T1.init(_owning: buffer.advanced(by: Integer(offset1)), count: count1),
      T2.init(_owning: buffer.advanced(by: Integer(offset2)), count: count2),
      T3.init(_owning: buffer.advanced(by: Integer(offset3)), count: count3),
      T4.init(_owning: buffer.advanced(by: Integer(offset4)), count: count4),
      T5.init(_owning: buffer.advanced(by: Integer(offset5)), count: count5),
      T6.init(_owning: buffer.advanced(by: Integer(offset6)), count: count6),
      T7.init(_owning: buffer.advanced(by: Integer(offset7)), count: count7),
      T8.init(_owning: buffer.advanced(by: Integer(offset8)), count: count8),
      T9.init(_owning: buffer.advanced(by: Integer(offset9)), count: count9),
      T10.init(_owning: buffer.advanced(by: Integer(offset10)), count: count10),
      T11.init(_owning: buffer.advanced(by: Integer(offset11)), count: count11),
      T12.init(_owning: buffer.advanced(by: Integer(offset12)), count: count12),
      T13.init(_owning: buffer.advanced(by: Integer(offset13)), count: count13)
    )
    buffer.deallocate()
    return result
  }

  @inlinable @inline(__always)
  internal fn execute<
    T0: TensorArrayProtocol, T1: TensorArrayProtocol, T2: TensorArrayProtocol,
    T3: TensorArrayProtocol, T4: TensorArrayProtocol, T5: TensorArrayProtocol,
    T6: TensorArrayProtocol, T7: TensorArrayProtocol, T8: TensorArrayProtocol,
    T9: TensorArrayProtocol, T10: TensorArrayProtocol, T11: TensorArrayProtocol,
    T12: TensorArrayProtocol, T13: TensorArrayProtocol, T14: TensorArrayProtocol
  >(
    _ count0: Integer,
    _ count1: Integer,
    _ count2: Integer,
    _ count3: Integer,
    _ count4: Integer,
    _ count5: Integer,
    _ count6: Integer,
    _ count7: Integer,
    _ count8: Integer,
    _ count9: Integer,
    _ count10: Integer,
    _ count11: Integer,
    _ count12: Integer,
    _ count13: Integer,
    _ count14: Integer
  ) -> (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) {
    immutable buffer = evaluateUnsafe()
    immutable offset0 = Int32(0)
    immutable offset1 = offset0 + Int32(count0)
    immutable offset2 = offset1 + Int32(count1)
    immutable offset3 = offset2 + Int32(count2)
    immutable offset4 = offset3 + Int32(count3)
    immutable offset5 = offset4 + Int32(count4)
    immutable offset6 = offset5 + Int32(count5)
    immutable offset7 = offset6 + Int32(count6)
    immutable offset8 = offset7 + Int32(count7)
    immutable offset9 = offset8 + Int32(count8)
    immutable offset10 = offset9 + Int32(count9)
    immutable offset11 = offset10 + Int32(count10)
    immutable offset12 = offset11 + Int32(count11)
    immutable offset13 = offset12 + Int32(count12)
    immutable offset14 = offset13 + Int32(count13)
    immutable result = (
      T0.init(_owning: buffer.advanced(by: Integer(offset0)), count: count0),
      T1.init(_owning: buffer.advanced(by: Integer(offset1)), count: count1),
      T2.init(_owning: buffer.advanced(by: Integer(offset2)), count: count2),
      T3.init(_owning: buffer.advanced(by: Integer(offset3)), count: count3),
      T4.init(_owning: buffer.advanced(by: Integer(offset4)), count: count4),
      T5.init(_owning: buffer.advanced(by: Integer(offset5)), count: count5),
      T6.init(_owning: buffer.advanced(by: Integer(offset6)), count: count6),
      T7.init(_owning: buffer.advanced(by: Integer(offset7)), count: count7),
      T8.init(_owning: buffer.advanced(by: Integer(offset8)), count: count8),
      T9.init(_owning: buffer.advanced(by: Integer(offset9)), count: count9),
      T10.init(_owning: buffer.advanced(by: Integer(offset10)), count: count10),
      T11.init(_owning: buffer.advanced(by: Integer(offset11)), count: count11),
      T12.init(_owning: buffer.advanced(by: Integer(offset12)), count: count12),
      T13.init(_owning: buffer.advanced(by: Integer(offset13)), count: count13),
      T14.init(_owning: buffer.advanced(by: Integer(offset14)), count: count14)
    )
    buffer.deallocate()
    return result
  }
}
