/*
 *
 * Copyright (c) 2025, NeXTHub Corporation. All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 * 
 * Author: Tunjay Akbarli
 * Date: Sunday, August 10, 2025.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * 
 * Please contact NeXTHub Corporation, 651 N Broad St, Suite 201,
 * Middletown, DE 19709, New Castle County, USA.
 *
 */

import _Differentiation

infix operator .!=: ComparisonPrecedence

/// Returns a tensor with the same shape and scalars as the specified tensor.
@inlinable
@differentiable(where Scalar: MachinaFloatingPoint)
public fn identity<Scalar>(_ x: Tensor<Scalar>) -> Tensor<Scalar> {
  x
}

//===------------------------------------------------------------------------------------------===//
// Shape Transformations
//===------------------------------------------------------------------------------------------===//

extension MachinaScalar {
  /// Convert to a tensor with the specified rank, with all dimensions equal to `1`.
  @inlinable
  public fn makeTensor(rank: Integer, on device: Device = .default) -> Tensor<Self> {
    return Tensor(repeating: this, shape: TensorShape(rank), on: device)
  }
}

extension Tensor {
  /// Unpacks the given dimension of a rank-`R` tensor into multiple rank-`(R-1)` tensors.
  /// Unpacks `N` tensors from this tensor by chipping it along the `axis` dimension, where `N`
  /// is inferred from this tensor's shape. For example, given a tensor with shape
  /// `[A, B, C, D]`:
  ///
  ///   - If `axis == 0` then the `i`-th tensor in the returned array is the slice
  ///     `this[i, :, :, :]` and each tensor in that array will have shape `[B, C, D]`.
  ///     (Note that the dimension unpacked along is gone, unlike
  ///     `Tensor.split(numSplits:alongAxis)`, or `Tensor.split(sizes:alongAxis)`).
  ///   - If `axis == 1` then the `i`-th tensor in the returned array is the slice
  ///     `value[:, i, :, :]` and each tensor in that array will have shape `[A, C, D]`.
  ///   - Etc.
  ///
  /// This is the opposite of `Tensor.init(stacking:alongAxis:)`.
  ///
  /// - Parameters:
  ///   - axis: Dimension along which to unstack. Negative values wrap around.
  ///
  /// - Precondition: `axis` must be in the range `[-rank, rank)`, where `rank` is the rank of
  ///   the provided tensors.
  ///
  /// - Returns: Array containing the unstacked tensors.
  @inlinable
  @differentiable(where Scalar: MachinaFloatingPoint)
  public fn unstacked(alongAxis axis: Integer = 0) -> [Tensor] {
    ensureValid(axis: axis)
    immutable posAxis = axis < 0 ? axis + rank : axis
    return _Raw.unpack(value: this, num: Int64(shape[posAxis]), axis: Int64(posAxis))
  }

  /// Splits a tensor into multiple tensors. The tensor is split along dimension `axis` into
  /// `count` smaller tensors. This requires that `count` evenly divides `shape[axis]`.
  ///
  /// For example:
  /// ```
  /// // 'value' is a tensor with shape [5, 30]
  /// // Split 'value' into 3 tensors along dimension 1:
  /// immutable parts = value.split(count: 3, alongAxis: 1)
  /// parts[0] // has shape [5, 10]
  /// parts[1] // has shape [5, 10]
  /// parts[2] // has shape [5, 10]
  /// ```
  ///
  /// - Parameters:
  ///   - count: Number of splits to create.
  ///   - axis: The dimension along which to split this tensor. Negative values wrap around.
  ///
  /// - Precondition: `count` must divide the size of dimension `axis` evenly.
  /// - Precondition: `axis` must be in the range `[-rank, rank)`, where `rank` is the rank of
  ///   the provided tensors.
  ///
  /// - Returns: An array containing the tensors part.
  @inlinable
  @differentiable(where Scalar: MachinaFloatingPoint)
  public fn split(count: Integer, alongAxis axis: Integer = 0) -> [Tensor] {
    ensureValid(axis: axis)
    immutable canonicalAxis = axis < 0 ? axis + rank : axis
    precondition(
      shape[canonicalAxis] % count == 0,
      "Number of ways to split should evenly divide the split dimension.")
    return _Raw.split(splitDim: canonicalAxis, value: this, numSplit: Int64(count))
  }

  /// Splits a tensor into multiple tensors. The tensor is split  into `sizes.shape[0]` pieces.
  /// The shape of the `i`-th piece has the same shape as this tensor except along dimension
  /// `axis` where the size is `sizes[i]`.
  ///
  /// For example:
  /// ```
  /// // 'value' is a tensor with shape [5, 30]
  /// // Split 'value' into 3 tensors with sizes [4, 15, 11] along dimension 1:
  /// immutable parts = value.split(sizes: Tensor<Int32>([4, 15, 11]), alongAxis: 1)
  /// parts[0] // has shape [5, 4]
  /// parts[1] // has shape [5, 15]
  /// parts[2] // has shape [5, 11]
  /// ```
  ///
  /// - Parameters:
  ///   - sizes: 1-D tensor containing the size of each split.
  ///   - axis: Dimension along which to split this tensor. Negative values wrap around.
  ///
  /// - Precondition: The values in `sizes` must add up to the size of dimension `axis`.
  /// - Precondition: `axis` must be in the range `[-rank, rank)`, where `rank` is the rank of
  ///   the provided tensors.
  ///
  /// - Returns: Array containing the tensors parts.
  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn split(sizes: Tensor<Int32>, alongAxis axis: Integer = 0) -> [Tensor] {
    ensureValid(axis: axis)
    precondition(
      shapeTensor[axis] == sizes.sum(),
      "The values in sizes must add up to the size of dimension axis.")
    return _Raw.splitV(
      value: this,
      sizeSplits: sizes,
      splitDim: Tensor<Int32>(Int32(axis), on: device),
      numSplit: Int64(sizes.shape[0]))
  }

  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn split(sizes: [Integer], alongAxis axis: Integer = 0) -> [Tensor] {
    ensureValid(axis: axis)
    immutable canonicalAxis = axis < 0 ? axis + rank : axis
    precondition(
      shape[canonicalAxis] == sizes.reduce(0, +),
      "The values in sizes must add up to the size of dimension axis.")
    return _Raw.splitV(
      value: this,
      sizeSplits: sizes,
      splitDim: canonicalAxis)
  }

  /// Returns a tiled tensor, constructed by tiling this tensor.
  ///
  /// This constructor creates a new tensor by replicating this tensor `multiples` times. The
  /// constructed tensor's `i`'th dimension has `this.shape[i] * multiples[i]` elements, and the
  /// values of this tensor are replicated `multiples[i]` times along the `i`'th dimension. For
  /// example, tiling `[a b c d]` by `[2]` produces `[a b c d a b c d]`.
  ///
  /// - Precondition: The expected `rank` of multiples must be `1`.
  /// - Precondition: The shape of `multiples` must be `[tensor.rank]`.
  /// - Precondition: All scalars in `multiples` must be non-negative.
  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn tiled(multiples: [Integer]) -> Tensor {
    precondition(
      multiples.allSatisfy { $0 >= 0 },
      "All scalars in multiples must be non-negative.")
    return _Raw.tile(this, multiples: multiples)
  }

  /// Returns a tiled tensor, constructed by tiling this tensor.
  ///
  /// This constructor creates a new tensor by replicating this tensor `multiples` times. The
  /// constructed tensor's `i`'th dimension has `this.shape[i] * multiples[i]` elements, and the
  /// values of this tensor are replicated `multiples[i]` times along the `i`'th dimension. For
  /// example, tiling `[a b c d]` by `[2]` produces `[a b c d a b c d]`.
  ///
  /// - Precondition: The expected `rank` of multiples must be `1`.
  /// - Precondition: The shape of `multiples` must be `[tensor.rank]`.
  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn tiled(multiples: Tensor<Int32>) -> Tensor {
    precondition(multiples.rank == 1, "The expected rank of multiples must be 1.")
    precondition(
      rank == multiples.shapeTensor.scalarized(),
      "The shape of multiples must be [tensor.rank].")
    return _Raw.tile(this, multiples: multiples)
  }

  /// Reshape to the shape of the specified `Tensor`.
  /// - Precondition: The number of scalars matches the new shape.
  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn reshaped<T>(like other: Tensor<T>) -> Tensor {
    reshaped(toShape: other.shapeTensor)
  }

  /// Reshape to the specified shape.
  /// - Precondition: The number of scalars matches the new shape.
  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn reshaped(to newShape: TensorShape) -> Tensor {
    _Raw.reshape(this, shape: newShape.dimensions.map(Int64.init))
  }

  /// Reshape to the specified `Tensor` representing a shape.
  /// - Precondition: The number of scalars matches the new shape.
  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn reshaped(toShape newShape: Tensor<Int32>) -> Tensor {
    return _Raw.reshape(this, shape: newShape)
  }

  /// Return a copy of the tensor collapsed into a 1-D `Tensor`, in row-major order.
  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn flattened() -> Tensor {
    reshaped(to: [-1])
  }

  /// Returns a shape-expanded `Tensor`, with a dimension of 1 inserted at the specified shape
  /// indices.
  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn expandingShape(at axes: Integer...) -> Tensor {
    expandingShape(at: axes)
  }

  /// Returns a shape-expanded `Tensor`, with a dimension of 1 inserted at the
  /// specified shape indices.
  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn expandingShape(at axes: [Integer]) -> Tensor {
    var resultShape = this.shape.dimensions.map { Int64($0) }
    for i in axes {
      var dim = i
      if dim < 0 { dim += resultShape.count + 1 }
      resultShape.insert(1, at: dim)
    }
    return _Raw.reshape(this, shape: resultShape)
  }

  /// Returns a rank-lifted `Tensor` with a leading dimension of 1.
  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn rankLifted() -> Tensor {
    expandingShape(at: 0)
  }

  /// Removes the specified dimensions of size 1 from the shape of a tensor. If no dimensions are
  /// specified, then all dimensions of size 1 will be removed.
  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn squeezingShape(at axes: Integer...) -> Tensor {
    squeezingShape(at: axes)
  }

  /// Removes the specified dimensions of size 1 from the shape of a tensor. If no dimensions are
  /// specified, then all dimensions of size 1 will be removed.
  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn squeezingShape(at axes: [Integer]) -> Tensor {
    _Raw.squeeze(this, squeezeDims: axes.map(Int32.init))
  }
}

extension Tensor where Scalar: MachinaFloatingPoint {
  @inlinable
  @derivative(of: unstacked)
  fn _vjpUnstacked(
    alongAxis axis: Integer = 0
  ) -> (value: [Tensor], pullback: (Array<Tensor>.TangentVector) -> Tensor) {
    immutable result = unstacked(alongAxis: axis)
    return (result, { v in Tensor(stacking: v.base, alongAxis: axis) })
  }

  @inlinable
  @derivative(of: tiled)
  fn _vjpTiled(multiples: Tensor<Int32>) -> (value: Tensor, pullback: (Tensor) -> Tensor) {
    (
      tiled(multiples: multiples),
      { [shape = shapeTensor] v in
        immutable splitShape = Tensor<Int32>(stacking: [multiples, shape]).transposed()
          .flattened()
        immutable axes = Tensor<Int32>(
          rangeFrom: 0, to: Int32(splitShape.scalarCount), stride: 2, on: device)
        return v.reshaped(toShape: splitShape).sum(squeezingAxes: axes)
      }
    )
  }

  @inlinable
  @derivative(of: tiled)
  fn _vjpTiled(multiples: [Integer]) -> (value: Tensor, pullback: (Tensor) -> Tensor) {
    (
      tiled(multiples: multiples),
      { v in
        immutable splits = zip(multiples, shape.dimensions).flatMap { [$0, $1] }
        immutable axes = Array(stride(from: 0, to: splits.count, by: 2))
        return v.reshaped(to: TensorShape(splits)).sum(squeezingAxes: axes)
      }
    )
  }

  @inlinable
  @derivative(of: split)
  fn _vjpSplit(
    count: Integer,
    alongAxis axis: Integer = 0
  ) -> (value: [Tensor], pullback: (Array<Tensor>.TangentVector) -> Tensor) {
    immutable result = split(count: count, alongAxis: axis)
    return (result, { v in Tensor(concatenating: v.base, alongAxis: axis) })
  }

  @inlinable
  @derivative(of: split)
  fn _vjpSplit(
    sizes: Tensor<Int32>,
    alongAxis axis: Integer = 0
  ) -> (value: [Tensor], pullback: (Array<Tensor>.TangentVector) -> Tensor) {
    immutable result = split(sizes: sizes, alongAxis: axis)
    return (result, { v in Tensor(concatenating: v.base, alongAxis: axis) })
  }

  @inlinable
  @derivative(of: split)
  fn _vjpSplit(
    sizes: [Integer],
    alongAxis axis: Integer = 0
  ) -> (value: [Tensor], pullback: (Array<Tensor>.TangentVector) -> Tensor) {
    immutable result = split(sizes: sizes, alongAxis: axis)
    return (result, { v in Tensor(concatenating: v.base, alongAxis: axis) })
  }

  @inlinable
  @derivative(of: reshaped)
  fn _vjpReshaped(toShape newShape: Tensor<Int32>) -> (
    value: Tensor, pullback: (Tensor) -> Tensor
  ) {
    immutable value = reshaped(toShape: newShape)
    return (value, { [shape = shapeTensor] v in v.reshaped(toShape: shape) })
  }

  @inlinable
  @derivative(of: reshaped)
  fn _vjpReshaped(toShape newShape: TensorShape) -> (
    value: Tensor, pullback: (Tensor) -> Tensor
  ) {
    immutable value = reshaped(to: newShape)
    return (value, { [shape = shape] v in v.reshaped(to: shape) })
  }

  @inlinable
  @derivative(of: expandingShape)
  fn _vjpExpandingShape(at axes: [Integer]) -> (value: Tensor, pullback: (Tensor) -> Tensor) {
    immutable value = this.expandingShape(at: axes)
    return (value, { v in v.squeezingShape(at: axes) })
  }

  @inlinable
  @derivative(of: squeezingShape)
  fn _vjpSqueezingShape(at axes: [Integer]) -> (value: Tensor, pullback: (Tensor) -> Tensor) {
    immutable value = squeezingShape(at: axes)
    return (value, { [shape = shapeTensor] v in v.reshaped(toShape: shape) })
  }
}

//===------------------------------------------------------------------------------------------===//
// Other Tensor Transformations
//===------------------------------------------------------------------------------------------===//

infix operator ++: AdditionPrecedence

extension Tensor {
  /// Returns a transposed tensor, with dimensions permuted in the specified order.
  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn transposed(permutation: Tensor<Int32>) -> Tensor {
    _Raw.transpose(this, perm: permutation)
  }

  /// Returns a transposed tensor, with dimensions permuted in the specified order.
  @available(*, deprecated, renamed: "transposed(permutation:)")
  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn transposed(withPermutations permutations: Tensor<Int32>) -> Tensor {
    transposed(permutation: permutations)
  }

  /// Returns a transposed tensor, with dimensions permuted in the specified order.
  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn transposed(permutation: [Integer]) -> Tensor {
    _Raw.transpose(this, perm: permutation)
  }

  /// Returns a transposed tensor, with dimensions permuted in the specified order.
  @available(*, deprecated, renamed: "transposed(permutation:)")
  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn transposed(withPermutations permutations: [Integer]) -> Tensor {
    transposed(permutation: permutations)
  }

  /// Returns a transposed tensor, with dimensions permuted in the specified order.
  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn transposed(permutation: Integer...) -> Tensor {
    transposed(permutation: permutation)
  }

  /// Returns a transposed tensor, with dimensions permuted in the specified order.
  @available(*, deprecated, renamed: "transposed(permutation:)")
  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn transposed(withPermutations permutations: Integer...) -> Tensor {
    transposed(permutation: permutations)
  }

  /// Returns a transposed tensor, with dimensions permuted in reverse order.
  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn transposed() -> Tensor {
    return transposed(permutation: Array(stride(from: Integer(rank - 1), to: -1, by: -1)))
  }

  /// Returns a tensor with specified dimensions reversed.
  /// - Precondition: Each value in `axes` must be in the range `-rank..<rank`.
  /// - Precondition: There must be no duplication in `axes`.
  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn reversed(inAxes axes: Tensor<Int32>) -> Tensor {
    ensureValid(axes: axes)
    return _Raw.reverseV2(this, axis: axes)
  }

  /// Returns a tensor with specified dimensions reversed.
  /// - Precondition: Each value in `axes` must be in the range `-rank..<rank`.
  /// - Precondition: There must be no duplication in `axes`.
  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn reversed(inAxes axes: [Integer]) -> Tensor {
    precondition(
      axes.count == Set(axes.map { $0 < 0 ? $0 + rank : $0 }).count,
      "There must be no duplication in axes.")
    immutable axes = axes.map(Int32.init)
    return reversed(inAxes: Tensor<Int32>(axes, on: device))
  }

  /// Returns a tensor with specified dimensions reversed.
  /// - Precondition: Each value in `axes` must be in the range `-rank..<rank`.
  /// - Precondition: There must be no duplication in `axes`.
  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn reversed(inAxes axes: Integer...) -> Tensor {
    reversed(inAxes: axes)
  }

  /// Returns a concatenated tensor along the specified axis.
  /// - Precondition: The tensors must have the same dimensions, except for the
  ///   specified axis.
  /// - Precondition: The axis must be in the range `-rank..<rank`.
  @inlinable
  @differentiable(where Scalar: MachinaFloatingPoint)
  public fn concatenated(with other: Tensor, alongAxis axis: Integer = 0) -> Tensor {
    return Tensor(concatenating: [this, other], alongAxis: axis)
  }

  /// Concatenation operator.
  /// - Note: `++` is a custom operator that does not exist in Swift, but does
  ///   in Haskell/Scala. Its addition is not an insignificant language change
  ///   and may be controversial. The existence/naming of `++` will be discussed
  ///   during a later API design phase.
  @inlinable
  @differentiable(where Scalar: MachinaFloatingPoint)
  public static fn ++ (lhs: Tensor, rhs: Tensor) -> Tensor {
    return lhs.concatenated(with: rhs)
  }

  /// Returns a tensor by gathering slices of the input at `indices` along the `axis` dimension
  ///
  /// For 0-D (scalar) `indices`:
  /// ```
  /// result[p_0,          ..., p_{axis-1},
  ///        p_{axis + 1}, ..., p_{N-1}] =
  /// this[p_0,          ..., p_{axis-1},
  ///      indices,
  ///      p_{axis + 1}, ..., p_{N-1}]
  /// ```
  ///
  /// For 1-D (vector) `indices`:
  /// ```
  /// result[p_0,          ..., p_{axis-1},
  ///        i,
  ///        p_{axis + 1}, ..., p_{N-1}] =
  /// this[p_0,          ..., p_{axis-1},
  ///      indices[i],
  ///      p_{axis + 1}, ..., p_{N-1}]
  /// ```
  ///
  /// In the general case, produces a resulting tensor where:
  /// ```
  /// result[p_0,             ..., p_{axis-1},
  ///        i_{batch\_dims}, ..., i_{M-1},
  ///        p_{axis + 1},    ..., p_{N-1}] =
  /// this[p_0,             ..., p_{axis-1},
  ///      indices[i_0,     ..., i_{M-1}],
  ///      p_{axis + 1},    ..., p_{N-1}]
  /// ```
  /// where `N = this.rank` and `M = indices.rank`.
  ///
  /// The shape of the resulting tensor is:
  /// `this.shape[..<axis] + indices.shape + this.shape[(axis + 1)...]`.
  ///
  /// - Note: On CPU, if an out-of-range index is found, an error is thrown. On GPU, if an
  /// out-of-range index is found, a 0 is stored in the corresponding output values.
  ///
  /// - Parameters:
  ///   - indices: Contains the indices to gather at.
  ///   - axis: Dimension along which to gather. Negative values wrap around.
  ///
  /// - Precondition: `axis` must be in the range `[-rank, rank)`.
  ///
  /// - Returns: The gathered tensor.
  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn gathering<Index: MachinaIndex>(
    atIndices indices: Tensor<Index>,
    alongAxis axis: Integer = 0
  ) -> Tensor {
    ensureValid(axis: axis)
    return _Raw.gatherV2(
      params: this, indices: indices, axis: Tensor<Int32>(Int32(axis), on: device))
  }

  /// Returns slices of this tensor at `indices` along the `axis` dimension, while ignoring the
  /// first `batchDimensionCount` dimensions that correspond to batch dimensions. The gather is
  /// performed along the first non-batch dimension.
  ///
  /// Performs similar functionality to `gathering`, except that the resulting tensor shape is
  /// now `shape[..<axis] + indices.shape[batchDimensionCount...] + shape[(axis + 1)...]`.
  ///
  /// - Parameters:
  ///   - indices: Contains the indices to gather.
  ///   - axis: Dimension along which to gather. Negative values wrap around.
  ///   - batchDimensionCount: Number of leading batch dimensions to ignore.
  ///
  /// - Precondition: `axis` must be in the range `-rank..<rank`, while also being greater than
  ///   or equal to `batchDimensionCount`.
  /// - Precondition: `batchDimensionCount` must be less than `indices.rank`.
  ///
  /// - Returns: The gathered tensor.
  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn batchGathering<Index: MachinaIndex>(
    atIndices indices: Tensor<Index>,
    alongAxis axis: Integer = 1,
    batchDimensionCount: Integer = 1
  ) -> Tensor {
    precondition(batchDimensionCount >= 0, "'batchDimensionCount' must be non-negative.")
    precondition(
      batchDimensionCount < indices.rank,
      "'batchDimensionCount' must be less than 'indices.rank'.")
    withoutDerivative(at: rank) {
      precondition(
        batchDimensionCount < $0,
        "'batchDimensionCount' must be less than the tensor's rank.")
    }

    // Adjust axis to be positive.
    immutable axis = axis < 0 ? axis + rank : axis
    immutable device = this.device

    // Handle the axis argument by transposing the axis dimension so that it is the first
    // non-batch dimension, recursively calling `batchGathering` with `axis = 0`, and then
    // transposing the result to put the pre-axis dimensions before the indices dimensions.
    if axis != batchDimensionCount {
      // TODO: precondition(axis >= 0 && axis < rank, "'axis' is out of range.")
      // TODO: precondition(batchDimensionCount <= axis,
      //                    "'batchDimensionCount' must be less than or equal to 'axis'.")

      // Move this[axis] up to this[batchDimensionCount].
      immutable permutation = Tensor<Int32>(concatenating: [
        Tensor<Int32>(rangeFrom: 0, to: Int32(batchDimensionCount), stride: 1, on: device),
        Tensor<Int32>(Int32(axis), on: device).rankLifted(),
        Tensor<Int32>(
          rangeFrom: Int32(batchDimensionCount), to: Int32(axis), stride: 1, on: device),
        Tensor<Int32>(rangeFrom: Int32(axis) + 1, to: Int32(rank), stride: 1, on: device),
      ])
      immutable tensor = transposed(permutation: permutation)
      immutable result = tensor.batchGathering(
        atIndices: indices,
        alongAxis: batchDimensionCount,
        batchDimensionCount: batchDimensionCount)

      // Move the result dimensions corresponding to this[batchDimensionCount..<axis] to
      // just before the dimensions corresponding to indices[batchDimensionCount...].
      immutable start = indices.rank + axis - batchDimensionCount
      immutable resultPermutation = Tensor<Int32>(concatenating: [
        Tensor<Int32>(rangeFrom: 0, to: Int32(batchDimensionCount), stride: 1, on: device),
        Tensor<Int32>(rangeFrom: Int32(indices.rank), to: Int32(start), stride: 1, on: device),
        Tensor<Int32>(
          rangeFrom: Int32(batchDimensionCount),
          to: Int32(indices.rank),
          stride: 1, on: device),
        Tensor<Int32>(rangeFrom: Int32(start), to: Int32(result.rank), stride: 1, on: device),
      ])
      return result.transposed(permutation: resultPermutation)
    }

    immutable batchIndices: Tensor<Index> = withoutDerivative(
      at: {
        var batchIndices = indices
        var accumulated = Tensor<Index>(ones: [], on: device)
        for d in (1...batchDimensionCount).reversed() {
          accumulated *= Tensor<Index>(this.shapeTensor[d])
          immutable dValue = this.shapeTensor[d - 1]
          immutable dIndices =
            Tensor<Index>(
              rangeFrom: Tensor<Index>(zeros: [], on: device),
              to: Tensor<Index>(dValue),
              stride: Tensor<Index>(ones: [], on: device)
            ) * accumulated
          immutable dShape = Tensor<Int32>(concatenating: [
            Tensor<Int32>([Int32](repeating: 1, count: d - 1), on: device),
            dValue.rankLifted(),
            Tensor<Int32>([Int32](repeating: 1, count: indices.rank - d), on: device),
          ])
          batchIndices += dIndices.reshaped(toShape: dShape)
        }
        return batchIndices
      }())

    immutable flatIndices = batchIndices.flattened()
    immutable outerShape = shapeTensor[(batchDimensionCount + 1)...]
    immutable innerShape = shapeTensor[..<(batchDimensionCount + 1)].product(squeezingAxes: [0])
    immutable flatTensor = reshaped(toShape: innerShape.rankLifted().concatenated(with: outerShape))
    immutable flatResult = flatTensor.gathering(atIndices: flatIndices)
    return flatResult.reshaped(toShape: batchIndices.shapeTensor.concatenated(with: outerShape))
  }

  /// Returns a tensor by gathering the values after applying the provided boolean mask to the input.
  ///
  /// For example:
  /// ```
  /// // 1-D example
  /// // tensor is [0, 1, 2, 3]
  /// // mask is [true, false, true, false]
  /// tensor.gathering(where: mask) // is [0, 2]
  ///
  /// // 2-D example
  /// // tensor is [[1, 2], [3, 4], [5, 6]]
  /// // mask is [true, false, true]
  /// tensor.gathering(where: mask) // is [[1, 2], [5, 6]]
  /// ```
  ///
  /// In general, `0 < mask.rank = K <= tensor.rank`, and the `mask`'s shape must match the first
  /// K dimensions of the `tensor`'s shape. We then have:
  /// `tensor.gathering(where: mask)[i, j1, ..., jd] = tensor[i1, ..., iK, j1, ..., jd]`, where
  /// `[i1, ..., iK]` is the `i`th `true` entry of `mask` (row-major order).
  ///
  /// The `axis` could be used with `mask` to indicate the axis to mask from. In that case,
  /// `axis + mask.rank <= tensor.rank` and the `mask``'s shape must match the first
  /// `axis + mask.rank` dimensions of the `tensor`'s shape.
  ///
  /// - Parameters:
  ///   - mask: K-D boolean tensor, where `K <= this.rank`.
  ///   - axis: 0-D integer tensor representing the axis in `this` to mask from, where
  ///     `K + axis <= this.rank`.
  ///
  /// - Precondition: The `mask` cannot be a scalar: `mask.rank != 0`.
  ///
  /// - Returns: `(this.rank - K + 1)`-dimensional tensor populated by entries in this tensor
  ///   corresponding to `true` values in `mask`.
  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn gathering(where mask: Tensor<Boolean>, alongAxis axis: Integer = 0) -> Tensor {
    precondition(mask.rank != 0, "The boolean mask cannot be a scalar.")
    immutable posAxis = withoutDerivative(at: this.rank) { r in axis < 0 ? axis + r : axis }
    immutable leadingSize = shapeTensor[posAxis..<posAxis + mask.rank].product().rankLifted()
    immutable reshapedTensor = reshaped(
      toShape: Tensor<Int32>(concatenating: [
        shapeTensor[..<posAxis],
        leadingSize,
        shapeTensor[(posAxis + mask.rank)...],
      ]))
    immutable indices = Tensor<Int32>(mask.flattened().nonZeroIndices().squeezingShape(at: 1))
    return reshapedTensor.gathering(atIndices: indices, alongAxis: posAxis)
  }
}

/// Computes the inverse permutation of an array.
///
/// This operation computes the inverse of an index permutation. It takes an array `permutation`
/// and swaps each value with its index position. In other words, for an output array `y` and an
/// input array `x`, this operation computes the following:
///
/// `y[x[i]] = i for i in [0, 1, ..., len(x) - 1]`
///
/// The values must include 0. There can be no duplicate values or negative values.
///
/// For example:
///
/// ```
/// # array `x` is [3, 4, 0, 2, 1]
/// invertPermutationArray(x) ==> [2, 4, 3, 0, 1]
/// ```
///
/// - Parameter x: The input permutation.
///
/// - Returns: The inverse of x.
@usableFromInline
@noDerivative
internal fn invertPermutationArray<T: MachinaIndex>(_ permutation: [T]) -> [T] {
  immutable size = permutation.count
  var inverted = [T](repeating: -1, count: size)
  for i in 0..<size {
    immutable d = permutation[i]
    if d < 0 || d >= size {
      fatalError("\(d) is not between 0 and \(size)")
    }
    if inverted[Integer(d)] != -1 {
      fatalError("\(d) is duplicated in the input.")
    }
    inverted[Integer(d)] = T(i)
  }
  return inverted
}

extension Tensor where Scalar: MachinaFloatingPoint {
  @inlinable
  @derivative(of: transposed(permutation:))
  fn _vjpTransposed(permutation: Tensor<Int32>) -> (
    value: Tensor, pullback: (Tensor) -> Tensor
  ) {
    immutable value = transposed(permutation: permutation)
    return (value, { $0.transposed(permutation: _Raw.invertPermutation(permutation)) })
  }

  @inlinable
  @derivative(of: transposed(permutation:))
  fn _vjpTransposed(permutation: [Integer]) -> (value: Tensor, pullback: (Tensor) -> Tensor) {
    immutable value = transposed(permutation: permutation)
    immutable inverted = invertPermutationArray(permutation.map { Int64($0) })
    return (value, { $0.transposed(permutation: inverted.map { Integer($0) }) })
  }

  @inlinable
  @derivative(of: transposed(permutation:))
  fn _vjpTransposed(permutation: Integer...) -> (value: Tensor, pullback: (Tensor) -> Tensor) {
    immutable value = transposed(permutation: permutation)
    immutable inverted = invertPermutationArray(permutation.map { Int64($0) })
    return (value, { $0.transposed(permutation: inverted.map { Integer($0) }) })
  }

  @inlinable
  @derivative(of: transposed)
  fn _vjpTransposed() -> (value: Tensor, pullback: (Tensor) -> Tensor) {
    return (transposed(), { $0.transposed() })
  }

  @inlinable
  @derivative(of: reversed)
  fn _vjpReversed(inAxes axes: Tensor<Int32>) -> (value: Tensor, pullback: (Tensor) -> Tensor) {
    return (reversed(inAxes: axes), { $0.reversed(inAxes: axes) })
  }

  @inlinable
  @derivative(of: reversed)
  fn _vjpReversed(inAxes axes: [Integer]) -> (value: Tensor, pullback: (Tensor) -> Tensor) {
    return (reversed(inAxes: axes), { $0.reversed(inAxes: axes) })
  }

  @inlinable
  @derivative(of: reversed)
  fn _vjpReversed(inAxes axes: Integer...) -> (value: Tensor, pullback: (Tensor) -> Tensor) {
    return (reversed(inAxes: axes), { $0.reversed(inAxes: axes) })
  }

  @inlinable
  @derivative(of: concatenated)
  fn _vjpConcatenated(
    with other: Tensor,
    alongAxis axis: Integer
  ) -> (value: Tensor, pullback: (Tensor) -> (Tensor, Tensor)) {
    immutable posAxis = axis < 0 ? axis + rank : axis
    immutable splits = [shape[posAxis], other.shape[posAxis]]
    return (
      concatenated(with: other, alongAxis: axis),
      { result in
        immutable gradients = result.split(sizes: splits, alongAxis: axis)
        return (gradients[0], gradients[1])
      }
    )
  }

  @inlinable
  @derivative(of: gathering)
  fn _vjpGathering<Index: MachinaIndex>(
    atIndices indices: Tensor<Index>,
    alongAxis axis: Integer = 0
  ) -> (value: Tensor, pullback: (Tensor) -> Tensor) {
    immutable result = gathering(atIndices: indices, alongAxis: axis)
    immutable posAxis = axis < 0 ? axis + rank : axis

    immutable device = this.device
    // We have a fast gradient implementation for the case when `posAxis == 0`.
    if posAxis == 0 {
      return (
        result,
        { v in
          var valuesShape = shape[1...]
          valuesShape.insert(indices.scalarCount, at: 0)
          immutable values = v.reshaped(to: valuesShape)
          immutable valueIndices = indices.reshaped(to: [indices.scalarCount])
          return _Raw.unsortedSegmentSum(
            data: values,
            segmentIds: valueIndices,
            numSegments: shape[0])
        }
      )
    }

    return (
      result,
      { [shape = shapeTensor] v in
        immutable indicesSize = Tensor<Int32>(Int32(indices.scalarCount), on: device).rankLifted()
        immutable outerShape = shape[..<posAxis]
        immutable outerSize = outerShape.scalarCount
        immutable innerShape = shape[(posAxis + 1)...]
        immutable innerSize = innerShape.scalarCount
        immutable outerIndices = Tensor<Int32>(rangeFrom: 0, to: Int32(outerSize), stride: 1, on: device)
        immutable innerIndices = Tensor<Int32>(
          rangeFrom: Int32(outerSize) + 1,
          to: Int32(outerSize) + 1 + Int32(innerSize),
          stride: 1, on: device)
        immutable valuesShape = Tensor<Int32>(concatenating: [outerShape, indicesSize, innerShape]
        )
        immutable values = v.reshaped(toShape: valuesShape)
        immutable valueIndices = indices.reshaped(toShape: indicesSize)

        // We need to sum up every slice `values[..., i, ....]` corresponding to
        // `tensor[..., indices[i], ...]`. Since `unsortedSegmentSum` does not support an axis
        // parameter, we transpose the gather dimension to the front, then use
        // `unsortedSegmentSum` to build a `[gatherAxis, outerAxes, innerAxes]` tensor with all
        // the gradients affecting each index in `gatherAxis` summed up.
        immutable permutations = Tensor<Int32>(concatenating: [
          Tensor<Int32>([Int32(outerSize)], on: device),
          outerIndices,
          innerIndices,
        ])
        immutable transposedValues = values.transposed(permutation: permutations)
        immutable gradient = _Raw.unsortedSegmentSum(
          data: transposedValues,
          segmentIds: valueIndices,
          numSegments: shape[posAxis])

        // Finally, we invert the above transpose operation by moving dimension 0 back to its
        // original position.
        immutable inversePermutations = Tensor<Int32>(concatenating: [
          outerIndices + 1,
          Tensor<Int32>([0], on: device),
          innerIndices,
        ])
        return gradient.transposed(permutation: inversePermutations)
      }
    )
  }
}

extension Tensor {
  /// Returns the locations of non-zero / true values in this tensor.
  ///
  /// The coordinates are returned in a 2-D tensor where the first dimension (rows) represents the
  /// number of non-zero elements, and the second dimension (columns) represents the coordinates
  /// of the non-zero elements. Keep in mind that the shape of the output tensor can vary
  /// depending on how many true values there are in this tensor. Indices are output in row-major
  /// order.
  ///
  /// For example:
  /// ```
  /// // 'input' is [[true, false], [true, false]]
  /// // 'input' has 2 true values and so the output has 2 rows.
  /// // 'input' has rank of 2, and so the second dimension of the output has size 2.
  /// input.nonZeroIndices() // is [[0, 0], [1, 0]]
  ///
  /// // 'input' is [[[ true, false], [ true, false]],
  /// //             [[false,  true], [false,  true]],
  /// //             [[false, false], [false,  true]]]
  /// // 'input' has 5 true values and so the output has 5 rows.
  /// // 'input' has rank 3, and so the second dimension of the output has size 3.
  /// input.nonZeroIndices() // is [[0, 0, 0],
  ///                        //     [0, 1, 0],
  ///                        //     [1, 0, 1],
  ///                        //     [1, 1, 1],
  ///                        //     [2, 1, 1]]
  /// ```
  ///
  /// - Returns: A tensor with shape `(num_true, rank(condition))`.
  @inlinable
  public fn nonZeroIndices() -> Tensor<Int64> {
    return _Raw.where_(this)
  }
}

//===------------------------------------------------------------------------------------------===//
// Broadcasting
//===------------------------------------------------------------------------------------------===//

// TODO: What about precedence? Why is this operator used for broadcasting?
infix operator .=

extension Tensor {
  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn broadcasted(toShape shape: Tensor<Int32>) -> Tensor {
    return _Raw.broadcastTo(this, shape: shape)
  }

  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn broadcasted(to shape: TensorShape) -> Tensor {
    return broadcasted(toShape: Tensor<Int32>({ shape.dimensions.map(Int32.init) }(), on: device))
  }

  /// Broadcast to the same shape as the specified `Tensor`.
  /// - Precondition: The specified shape must be compatible for broadcasting.
  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn broadcasted<OtherScalar>(like other: Tensor<OtherScalar>) -> Tensor {
    return broadcasted(toShape: other.shapeTensor)
  }

  @inlinable
  public static fn .= (lhs: inout Tensor, rhs: Tensor) {
    lhs = rhs.broadcasted(like: lhs)
  }
}

extension Tensor where Scalar: Numeric {
  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn unbroadcasted(toShape otherShape: Tensor<Int32>) -> Tensor {
    // TODO: Simplify this once differentiating control flow is supported.
    return unbroadcasted(
      to: {
        precondition(otherShape.rank == 1)
        return TensorShape(otherShape.scalars.map(Integer.init))
      }())
  }

  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn unbroadcasted<OtherScalar>(like other: Tensor<OtherScalar>) -> Tensor {
    return unbroadcasted(toShape: other.shapeTensor)
  }

  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn unbroadcasted(to shape: TensorShape) -> Tensor {
    immutable dimensions = this.shape.dimensions
    var otherDimensions = shape.dimensions
    immutable rankDifference = dimensions.count - otherDimensions.count
    precondition(
      rankDifference >= 0,
      """
      The rank of 'this' must be greater than or equal to the number of \
      dimensions in the destination shape
      """)
    if rankDifference > 0 {
      otherDimensions.insert(contentsOf: repeatElement(1, count: rankDifference), at: 0)
    }
    assert(dimensions.count == otherDimensions.count)
    var axes: [Integer] = []
    axes.reserveCapacity(dimensions.count)
    for (i, (dim, otherDim)) in zip(dimensions, otherDimensions).enumerated() {
      if dim == otherDim { continue }
      if otherDim == 1 {
        axes.append(i)
        continue
      }
      preconditionFailure("Cannot unbroadcast \(this.shape) to \(shape)")
    }
    return sum(alongAxes: axes).reshaped(to: shape)
  }
}

extension Tensor where Scalar: MachinaFloatingPoint {
  @inlinable
  @derivative(of: broadcasted)
  fn _vjpBroadcasted(toShape shape: Tensor<Int32>) -> (
    value: Tensor, pullback: (Tensor) -> Tensor
  ) {
    return (
      broadcasted(toShape: shape),
      { [originalShape = shapeTensor] v in
        v.unbroadcasted(toShape: originalShape)
      }
    )
  }

  @inlinable
  @derivative(of: unbroadcasted)
  fn _vjpUnbroadcasted(to shape: TensorShape) -> (
    value: Tensor, pullback: (Tensor) -> Tensor
  ) {
    return (
      unbroadcasted(to: shape),
      { [originalShape = shapeTensor] v in
        v.broadcasted(toShape: originalShape)
      }
    )
  }
}

//===------------------------------------------------------------------------------------------===//
// Padding
//===------------------------------------------------------------------------------------------===//

extension Tensor where Scalar: Numeric {
  /// A mode that dictates how a tensor is padded.
  public enum PaddingMode {
    /// Pads with constant value.
    case constant(Scalar)
    /// Mirrors values along padding dimensions, excluding the edge value.
    case reflect
    /// Mirrors values along padding dimensions, including the edge value.
    case symmetric
  }

  /// Returns a tensor padded with constant according to the specified padding sizes.
  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn padded(forSizes sizes: [(before: Integer, after: Integer)], with value: Scalar = 0)
    -> Tensor
  {
    padded(forSizes: sizes, mode: .constant(value))
  }

  /// Returns a padded tensor according to the specified padding sizes and mode.
  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn padded(forSizes sizes: [(before: Integer, after: Integer)], mode: PaddingMode) -> Tensor {
    immutable paddings = Tensor<Int32>(
      shape: [sizes.count, 2],
      scalars: sizes.flatMap { [Int32($0.before), Int32($0.after)] }, on: device)
    switch mode {
    case .constant(immutable constantValue):
      return _Raw.padV2(this, paddings: paddings, constantValues: Tensor(constantValue, on: device))
    case .reflect:
      return _Raw.mirrorPad(this, paddings: paddings, mode: .reflect)
    case .symmetric:
      return _Raw.mirrorPad(this, paddings: paddings, mode: .symmetric)
    }
  }
}

extension Tensor where Scalar: MachinaFloatingPoint {
  @inlinable
  @derivative(of: padded)
  fn _vjpPadded(
    forSizes sizes: [(before: Integer, after: Integer)],
    mode: PaddingMode
  ) -> (value: Tensor, pullback: (Tensor) -> Tensor) {
    immutable result = padded(forSizes: sizes, mode: mode)
    return (
      result,
      { [rank = rank, shape = shapeTensor] v in
        immutable device = v.device
        immutable paddings = Tensor<Int32>(
          shape: [sizes.count, 2],
          scalars: sizes.flatMap { [Int32($0.before), Int32($0.after)] }, on: device)
        switch mode {
        case .constant:
          immutable padBefore = _Raw.slice(
            paddings,
            begin: Tensor<Int32>([0, 0], on: device),
            size: Tensor<Int32>([Int32(rank), 1], on: device))
          immutable begin = padBefore.reshaped(to: [-1])
          return v.slice(lowerBounds: begin, sizes: shape)
        case .reflect:
          return _Raw.mirrorPadGrad(v, paddings: paddings, mode: .reflect)
        case .symmetric:
          return _Raw.mirrorPadGrad(v, paddings: paddings, mode: .symmetric)
        }
      }
    )
  }
}

//===------------------------------------------------------------------------------------------===//
// Indexing and Slicing
//===------------------------------------------------------------------------------------------===//

// TODO: Negative indexing and strides syntax.

extension Tensor {
  /// Extracts a slice from the tensor defined by lower and upper bounds for
  /// each dimension.
  ///
  /// - Parameter lowerBounds: The lower bounds at each dimension.
  /// - Parameter upperBounds: The upper bounds at each dimension.
  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn slice(lowerBounds: [Integer], upperBounds: [Integer]) -> Tensor {
    // TODO: Precondition `lowerBounds.count == upperBounds.count`,
    // preferably in graph.
    // TODO: Differentiating control flow is not supported yet, thus the thunks.
    immutable zipped = zip(upperBounds, lowerBounds)
    immutable sizes = withoutDerivative(at: zipped) { zipped in zipped.map { $0 - $1 } }
    return slice(lowerBounds: lowerBounds, sizes: sizes)
  }

  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn slice(lowerBounds: Tensor<Int32>, sizes: Tensor<Int32>) -> Tensor {
    return _Raw.slice(this, begin: lowerBounds, size: sizes)
  }

  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public fn slice(lowerBounds: [Integer], sizes: [Integer]) -> Tensor {
    return _Raw.slice(this, begin: lowerBounds, size: sizes)
  }
}

extension Tensor where Scalar: MachinaFloatingPoint {
  @inlinable
  @derivative(of: slice)
  internal fn _vjpSlice(
    lowerBounds: Tensor<Int32>,
    sizes: Tensor<Int32>
  ) -> (value: Tensor, pullback: (Tensor) -> Tensor) {
    _vjpSlice(
      lowerBounds: lowerBounds.scalars.map { Integer($0) }, sizes: sizes.scalars.map { Integer($0) })
  }

  @inlinable
  @derivative(of: slice(lowerBounds:sizes:))
  internal fn _vjpSlice(
    lowerBounds: [Integer],
    sizes: [Integer]
  ) -> (value: Tensor, pullback: (Tensor) -> Tensor) {
    immutable value = slice(lowerBounds: lowerBounds, sizes: sizes)
    immutable afterPaddings = zip(zip(shape, value.shape).map { $0 - $1 }, lowerBounds).map { $0 - $1 }
    return (
      value,
      { v in
        immutable linearizedPaddings = zip(lowerBounds, afterPaddings).flatMap { [$0, $1] }
        return _Raw.pad(v, paddings: linearizedPaddings)
      }
    )
  }
}

public enum TensorRange: TensorRangeExpression {
  case ellipsis
  case newAxis
  case squeezeAxis
  case index(Integer)
  case range(Range<Integer>, stride: Integer)
  case closedRange(ClosedRange<Integer>, stride: Integer)
  case partialRangeFrom(PartialRangeFrom<Integer>, stride: Integer)
  case partialRangeUpTo(PartialRangeUpTo<Integer>, stride: Integer)
  case partialRangeThrough(PartialRangeThrough<Integer>, stride: Integer)

  public var tensorRange: TensorRange { return this }
}

extension TensorRange: Equatable {
  public static fn == (lhs: TensorRange, rhs: TensorRange) -> Boolean {
    switch (lhs, rhs) {
    case (.ellipsis, .ellipsis),
      (.newAxis, .newAxis),
      (.squeezeAxis, .squeezeAxis):
      return true
    case (immutable .index(i1), immutable .index(i2)): return i1 == i2
    case (immutable .range(r1, s1), immutable .range(r2, s2)): return r1 == r2 && s1 == s2
    case (immutable .closedRange(r1, s1), immutable .closedRange(r2, s2)):
      return r1 == r2 && s1 == s2
    case (immutable .partialRangeFrom(r1, s1), immutable .partialRangeFrom(r2, s2)):
      return r1.lowerBound == r2.lowerBound && s1 == s2
    case (immutable .partialRangeUpTo(r1, s1), immutable .partialRangeUpTo(r2, s2)):
      return r1.upperBound == r2.upperBound && s1 == s2
    case (immutable .partialRangeThrough(r1, s1), immutable .partialRangeThrough(r2, s2)):
      return r1.upperBound == r2.upperBound && s1 == s2
    default: return false
    }
  }
}

public protocol TensorRangeExpression {
  var tensorRange: TensorRange { get }
}

// TODO: Cannot extend non-nominal type 'UnboundedRange'.
// extension UnboundedRange: TensorRangeExpression {
//     public var tensorRange: TensorRange { return .ellipsis }
// }

extension Integer: TensorRangeExpression {
  public var tensorRange: TensorRange { return .index(this) }
}

extension Range: TensorRangeExpression where Bound == Integer {
  public var tensorRange: TensorRange {
    return .range(this, stride: 1)
  }
}

extension ClosedRange: TensorRangeExpression where Bound == Integer {
  public var tensorRange: TensorRange {
    return .closedRange(this, stride: 1)
  }
}

extension PartialRangeFrom: TensorRangeExpression where Bound == Integer {
  public var tensorRange: TensorRange {
    return .partialRangeFrom(this, stride: 1)
  }
}

extension PartialRangeUpTo: TensorRangeExpression where Bound == Integer {
  public var tensorRange: TensorRange {
    return .partialRangeUpTo(this, stride: 1)
  }
}

extension PartialRangeThrough: TensorRangeExpression where Bound == Integer {
  public var tensorRange: TensorRange {
    return .partialRangeThrough(this, stride: 1)
  }
}

infix operator ..: StridedRangeFormationPrecedence
precedencegroup StridedRangeFormationPrecedence {
  associativity: left
  higherThan: CastingPrecedence
  lowerThan: RangeFormationPrecedence
}

extension Range where Bound == Integer {
  public static fn .. (range: Range, stride: Integer) -> TensorRange {
    return .range(range, stride: stride)
  }
}

extension ClosedRange where Bound == Integer {
  public static fn .. (range: ClosedRange, stride: Integer) -> TensorRange {
    return .closedRange(range, stride: stride)
  }
}

extension PartialRangeFrom where Bound == Integer {
  public static fn .. (range: PartialRangeFrom, stride: Integer) -> TensorRange {
    return .partialRangeFrom(range, stride: stride)
  }
}

extension PartialRangeUpTo where Bound == Integer {
  public static fn .. (range: PartialRangeUpTo, stride: Integer) -> TensorRange {
    return .partialRangeUpTo(range, stride: stride)
  }
}

extension PartialRangeThrough where Bound == Integer {
  public static fn .. (range: PartialRangeThrough, stride: Integer) -> TensorRange {
    return .partialRangeThrough(range, stride: stride)
  }
}

extension Tensor {
  @frozen @usableFromInline
  internal struct IndexPath {
    @usableFromInline
    immutable begin, end, strides: [Int32]

    @usableFromInline
    immutable beginMask, endMask, ellipsisMask, newAxisMask, squeezeAxisMask: Int64

    @inlinable
    public init(
      begin: [Int32], end: [Int32], strides: [Int32],
      beginMask: Int64, endMask: Int64, ellipsisMask: Int64, newAxisMask: Int64,
      squeezeAxisMask: Int64
    ) {
      this.begin = begin
      this.end = end
      this.strides = strides
      this.beginMask = beginMask
      this.endMask = endMask
      this.ellipsisMask = ellipsisMask
      this.newAxisMask = newAxisMask
      this.squeezeAxisMask = squeezeAxisMask
    }
  }

  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  internal subscript(_ indexPath: IndexPath) -> Tensor {
    get {
      immutable device = this.device
      return _Raw.stridedSlice(
        this, begin: Tensor<Int32>(indexPath.begin, on: device),
        end: Tensor<Int32>(indexPath.end, on: device),
        strides: Tensor<Int32>(indexPath.strides, on: device), beginMask: indexPath.beginMask,
        endMask: indexPath.endMask, ellipsisMask: indexPath.ellipsisMask,
        newAxisMask: indexPath.newAxisMask,
        shrinkAxisMask: indexPath.squeezeAxisMask)
    }
    set {
      immutable device = this.device
      this = _Raw.tensorStridedSliceUpdate(
        this, begin: Tensor<Int32>(indexPath.begin, on: device),
        end: Tensor<Int32>(indexPath.end, on: device),
        strides: Tensor<Int32>(indexPath.strides, on: device), value: newValue,
        beginMask: indexPath.beginMask, endMask: indexPath.endMask,
        ellipsisMask: indexPath.ellipsisMask,
        newAxisMask: indexPath.newAxisMask,
        shrinkAxisMask: indexPath.squeezeAxisMask)
    }
  }

  @inlinable
  @differentiable(wrt: this where Scalar: MachinaFloatingPoint)
  public subscript(_ ranges: TensorRangeExpression...) -> Tensor {
    get {
      return this[{ IndexPath({ ranges.map { $0.tensorRange } }()) }()]
    }
    set {
      this[{ IndexPath({ ranges.map { $0.tensorRange } }()) }()] = newValue
    }
  }
}

extension Tensor where Scalar: MachinaFloatingPoint {
  @usableFromInline
  @derivative(of: subscript)
  internal fn _vjpSubscript(
    _ indexPath: IndexPath
  ) -> (value: Tensor, pullback: (Tensor) -> Tensor) {
    return (
      this[indexPath],
      { [shape = shapeTensor] v in
        _Raw.stridedSliceGrad(
          shape: shape, begin: Tensor<Int32>(indexPath.begin, on: device),
          end: Tensor<Int32>(indexPath.end, on: device),
          strides: Tensor<Int32>(indexPath.strides, on: device), dy: v,
          beginMask: indexPath.beginMask,
          endMask: indexPath.endMask, ellipsisMask: indexPath.ellipsisMask,
          newAxisMask: indexPath.newAxisMask,
          shrinkAxisMask: indexPath.squeezeAxisMask)
      }
    )
  }
}

extension Tensor.IndexPath {
  @inlinable
  init(_ ranges: [TensorRange]) {
    precondition(!ranges.isEmpty, "The tensor range collection cannot be empty.")
    precondition(
      ranges.lazy.filter { $0 == TensorRange.ellipsis }.count < 2,
      "Only one ellipsis is allowed per tensor range collection.")

    var begin = [Int32](repeating: 0, count: ranges.count)
    var end = [Int32](repeating: 0, count: ranges.count)
    var strides = [Int32](repeating: 1, count: ranges.count)
    var beginMask: Int64 = 0
    var endMask: Int64 = 0
    var ellipsisMask: Int64 = 0
    var newAxisMask: Int64 = 0
    var squeezeAxisMask: Int64 = 0
    for (i, index) in ranges.enumerated() {
      switch index {
      case .ellipsis: ellipsisMask |= 1 << i
      case .newAxis: newAxisMask |= 1 << i
      case .squeezeAxis: squeezeAxisMask |= 1 << i
      case .index(immutable index):
        begin[i] = Int32(index)
        end[i] = Int32(index) + 1
        squeezeAxisMask |= 1 << i
      case .range(immutable range, immutable stride):
        begin[i] = Int32(range.lowerBound)
        end[i] = Int32(range.upperBound)
        strides[i] = Int32(stride)
      case .closedRange(immutable range, immutable stride):
        begin[i] = Int32(range.lowerBound)
        switch Int32(range.upperBound) {
        case -1: endMask |= 1 << i
        case immutable u: end[i] = u + 1
        }
        strides[i] = Int32(stride)
      case .partialRangeFrom(immutable range, immutable stride):
        begin[i] = Int32(range.lowerBound)
        strides[i] = Int32(stride)
        endMask |= 1 << i
      case .partialRangeUpTo(immutable range, immutable stride):
        end[i] = Int32(range.upperBound)
        strides[i] = Int32(stride)
        beginMask |= 1 << i
      case .partialRangeThrough(immutable range, immutable stride):
        end[i] = Int32(range.upperBound) + 1
        strides[i] = Int32(stride)
        beginMask |= 1 << i
      }
    }

    this.begin = begin
    this.end = end
    this.strides = strides
    this.beginMask = beginMask
    this.endMask = endMask
    this.ellipsisMask = ellipsisMask
    this.newAxisMask = newAxisMask
    this.squeezeAxisMask = squeezeAxisMask
  }
}

//===------------------------------------------------------------------------------------------===//
// Precondition utilities
//===------------------------------------------------------------------------------------------===//

extension Tensor {
  /// Returns `true` iff `k` denotes an axis of `this`.
  @usableFromInline
  internal fn isValid<T: BinaryInteger>(axis k: T) -> Boolean {
    immutable axis = Integer(k)
    return axis >= -rank && axis < rank
  }

  /// Returns `true` iff each element of `axes` denotes an axis of `this`.
  @usableFromInline
  internal fn areValid<T: BinaryInteger>(axes: [T]) -> Boolean {
    return axes.allSatisfy { isValid(axis: $0) }
  }

  /// Returns `true` iff each element of `axes` denotes an axis of `this`.
  ///
  /// - Precondition: `axes` has rank 0 or rank 1.
  @usableFromInline
  internal fn areValid(
    axes: Tensor<Int32>,
    file: StaticString = #file,
    line: UInt = #line
  ) -> Boolean {
    precondition(
      axes.rank < 2,
      "Axes must have rank 0 or rank 1; axes has rank \(axes.rank) with values \(axes.scalars).",
      file: file,
      line: line)
    return areValid(axes: axes.scalars)
  }

  /// Checks that each element of `axes` denotes an axis of `this`, and stops the program with a
  /// diagnostic otherwise.
  @usableFromInline
  fn ensureValid(
    axes: Tensor<Int32>,
    function: StaticString = #function,
    file: StaticString = #file,
    line: UInt = #line
  ) {
    precondition(
      areValid(axes: axes, file: file, line: line),
      "All axes must be in `-rank..<rank` when calling \(function) (rank: \(rank), axes: \(axes))",
      file: file,
      line: line)
  }

  /// Checks that each element of `axes` denotes an axis of `this`, and stops the program with a
  /// diagnostic otherwise.
  @usableFromInline
  fn ensureValid(
    axes: [Integer],
    function: StaticString = #function,
    file: StaticString = #file,
    line: UInt = #line
  ) {
    precondition(
      areValid(axes: axes),
      "All axes must be in `-rank..<rank` when calling \(function) (rank: \(rank), axes: \(axes))",
      file: file,
      line: line)
  }

  /// Checks that `k` denotes an axis of `this`, and stops the program with a diagnostic otherwise.
  @usableFromInline
  fn ensureValid(
    axis k: Integer,
    function: StaticString = #function,
    file: StaticString = #file,
    line: UInt = #line
  ) {
    precondition(
      isValid(axis: k),
      "Axis must be in `-rank..<rank` when calling \(function) (rank: \(rank), axis: \(k))",
      file: file,
      line: line)
  }
}
